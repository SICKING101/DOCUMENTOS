import { DOM } from '../dom.js';
import { CONFIG } from '../config.js';
import { apiCall } from '../api.js';
import { setLoadingState, showAlert, formatFileSize, getFileIcon, formatDate } from '../utils.js';

// =============================================================================
// ESTADO DE SUBIDA M√öLTIPLE
// =============================================================================
class MultipleUploadState {
    constructor() {
        this.files = [];
        this.currentUploads = [];
        this.completedUploads = [];
        this.failedUploads = [];
        this.isUploading = false;
        this.totalSize = 0;
        this.commonCategory = '';
        this.commonPersonId = '';
        this.expirationDays = null;
        this.uploadStrategy = 'sequential';
        this.autoGenerateDescriptions = true;
        this.notifyPerson = false;
    }

    reset() {
        this.files = [];
        this.currentUploads = [];
        this.completedUploads = [];
        this.failedUploads = [];
        this.isUploading = false;
        this.totalSize = 0;
        this.commonCategory = '';
        this.commonPersonId = '';
        this.expirationDays = null;
    }

    addFiles(newFiles) {
        console.group('üì¶ Agregando archivos m√∫ltiples');
        
        for (const file of newFiles) {
            // Verificar si ya existe
            const existingFile = this.files.find(f => 
                f.name === file.name && f.size === file.size
            );
            
            if (!existingFile) {
                // Validar archivo individual
                if (this.validateSingleFile(file)) {
                    const fileObj = {
                        file: file,
                        id: this.generateFileId(file),
                        status: 'pending',
                        progress: 0,
                        error: null,
                        description: file.name.replace(/\.[^/.]+$/, ""), // Nombre sin extensi√≥n
                        customCategory: '',
                        customPersonId: '',
                        customExpirationDate: null
                    };
                    
                    this.files.push(fileObj);
                    this.totalSize += file.size;
                    
                    console.log(`‚úÖ Archivo agregado: ${file.name} (${formatFileSize(file.size)})`);
                }
            } else {
                console.log(`‚ö†Ô∏è Archivo duplicado ignorado: ${file.name}`);
            }
        }
        
        console.log(`üìä Total archivos: ${this.files.length}, Tama√±o total: ${formatFileSize(this.totalSize)}`);
        console.groupEnd();
    }

    removeFile(fileId) {
        const index = this.files.findIndex(f => f.id === fileId);
        if (index !== -1) {
            const removedFile = this.files[index];
            this.totalSize -= removedFile.file.size;
            this.files.splice(index, 1);
            console.log(`üóëÔ∏è Archivo removido: ${removedFile.file.name}`);
            return true;
        }
        return false;
    }

    validateSingleFile(file) {
        try {
            console.log(`üîç Validando archivo: ${file.name}`);
            
            // Validar tipo de archivo
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (!CONFIG.ALLOWED_FILE_TYPES.includes(fileExtension)) {
                console.error(`‚ùå Tipo no permitido: ${fileExtension}`);
                showAlert(
                    `"${file.name}" - Tipo no permitido. Formatos aceptados: ${CONFIG.ALLOWED_FILE_TYPES.join(', ').toUpperCase()}`,
                    'error'
                );
                return false;
            }

            // Validar tama√±o individual
            if (file.size > CONFIG.MAX_FILE_SIZE) {
                console.error(`‚ùå Tama√±o excedido: ${formatFileSize(file.size)} > ${formatFileSize(CONFIG.MAX_FILE_SIZE)}`);
                showAlert(
                    `"${file.name}" - Excede el tama√±o m√°ximo por archivo (${formatFileSize(CONFIG.MAX_FILE_SIZE)})`,
                    'error'
                );
                return false;
            }

            // Validar tama√±o total (si ya hay archivos)
            if (this.totalSize + file.size > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
                console.error(`‚ùå Tama√±o total excedido`);
                showAlert(
                    `"${file.name}" - Excede el tama√±o total permitido para m√∫ltiples archivos`,
                    'error'
                );
                return false;
            }

            console.log(`‚úÖ Archivo v√°lido: ${file.name}`);
            return true;

        } catch (error) {
            console.error(`‚ùå Error validando archivo ${file.name}:`, error);
            showAlert(`Error validando "${file.name}": ${error.message}`, 'error');
            return false;
        }
    }

    validateAllFiles() {
        console.group('üîç Validando todos los archivos');
        
        const errors = [];
        
        // Verificar l√≠mite de archivos
        if (this.files.length > CONFIG.MAX_MULTIPLE_FILES) {
            errors.push(`M√°ximo ${CONFIG.MAX_MULTIPLE_FILES} archivos permitidos`);
        }

        // Verificar tama√±o total
        if (this.totalSize > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
            errors.push(`Tama√±o total excedido (${formatFileSize(this.totalSize)} > ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)})`);
        }

        // Verificar que haya archivos
        if (this.files.length === 0) {
            errors.push('No hay archivos seleccionados');
        }

        // Verificar categor√≠a si se requiere
        if (this.commonCategory === '' && this.files.some(f => f.customCategory === '')) {
            errors.push('Debe seleccionar una categor√≠a para todos los archivos o individualmente');
        }

        if (errors.length > 0) {
            console.error('‚ùå Errores de validaci√≥n:', errors);
            errors.forEach(error => showAlert(error, 'error'));
            console.groupEnd();
            return false;
        }

        console.log('‚úÖ Todos los archivos son v√°lidos');
        console.groupEnd();
        return true;
    }

    generateFileId(file) {
        return `${file.name}_${file.size}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    getStats() {
        return {
            total: this.files.length,
            pending: this.files.filter(f => f.status === 'pending').length,
            uploading: this.files.filter(f => f.status === 'uploading').length,
            completed: this.files.filter(f => f.status === 'completed').length,
            failed: this.files.filter(f => f.status === 'failed').length,
            totalSize: this.totalSize,
            uploadedSize: this.files
                .filter(f => f.status === 'completed')
                .reduce((sum, f) => sum + f.file.size, 0)
        };
    }

    logState() {
        console.group('üìä Estado de Subida M√∫ltiple');
        const stats = this.getStats();
        console.table({
            'Total Archivos': stats.total,
            'Pendientes': stats.pending,
            'Subiendo': stats.uploading,
            'Completados': stats.completed,
            'Fallidos': stats.failed,
            'Tama√±o Total': formatFileSize(stats.totalSize),
            'Subido': formatFileSize(stats.uploadedSize)
        });
        console.groupEnd();
    }
}

// Instancia global del estado de subida m√∫ltiple
const multipleUploadState = new MultipleUploadState();

// =============================================================================
// FUNCIONES DE DOCUMENTOS (CRUD) - ACTUALIZADO
// =============================================================================
function openDocumentModal() {
    console.group('üìÑ Abriendo modal de documento');
    
    // Resetear formularios
    DOM.documentForm.reset();
    DOM.fileInfo.style.display = 'none';
    DOM.uploadDocumentBtn.disabled = true;
    DOM.uploadMultipleDocumentsBtn.disabled = true;
    
    // Resetear estado
    window.appState.selectedFile = null;
    multipleUploadState.reset();
    
    // Resetear UI
    DOM.fileUploadContainer.classList.remove('upload__container--dragover');
    DOM.multipleFileUploadContainer.classList.remove('upload__container--dragover');
    
    // Configurar modo √∫nico por defecto
    switchUploadMode('single');
    
    // Poblar selects
    populateDocumentCategorySelect();
    populateMultipleCategorySelect();
    if (typeof window.populatePersonSelect === 'function') {
        window.populatePersonSelect();
        window.populatePersonSelect(DOM.multipleDocumentPerson);
    }
    
    // Mostrar modal
    DOM.documentModal.style.display = 'flex';
    
    // Actualizar UI
    updateMultipleUploadUI();
    
    console.log('‚úÖ Modal de documento abierto');
    console.groupEnd();
}

function closeDocumentModal() {
    console.log('‚ùå Cerrando modal de documento');
    DOM.documentModal.style.display = 'none';
    
    // Si est√° subiendo, preguntar
    if (multipleUploadState.isUploading) {
        if (confirm('Hay archivos subiendo. ¬øSeguro que quieres cancelar?')) {
            cancelMultipleUpload();
        } else {
            DOM.documentModal.style.display = 'flex';
            return;
        }
    }
}

function switchUploadMode(mode) {
    console.log(`üîÑ Cambiando a modo: ${mode}`);
    
    // Actualizar tabs
    DOM.uploadTabs.forEach(tab => {
        if (tab.dataset.mode === mode) {
            tab.classList.add('upload__tab--active');
        } else {
            tab.classList.remove('upload__tab--active');
        }
    });
    
    // Mostrar/ocultar contenedores
    if (mode === 'single') {
        DOM.singleUploadContainer.classList.add('upload__mode--active');
        DOM.multipleUploadContainer.classList.remove('upload__mode--active');
        DOM.uploadDocumentBtn.style.display = 'flex';
        DOM.uploadMultipleDocumentsBtn.style.display = 'none';
    } else {
        DOM.singleUploadContainer.classList.remove('upload__mode--active');
        DOM.multipleUploadContainer.classList.add('upload__mode--active');
        DOM.uploadDocumentBtn.style.display = 'none';
        DOM.uploadMultipleDocumentsBtn.style.display = 'flex';
        
        // Actualizar UI de m√∫ltiple
        updateMultipleUploadUI();
    }
    
    // Actualizar estado
    window.appState.uploadMode = mode;
}

// =============================================================================
// DRAG AND DROP MEJORADO
// =============================================================================
function setupFileDragAndDrop() {
    console.log('üîß Configurando drag and drop...');
    
    // Configurar para modo √∫nico
    if (DOM.fileUploadContainer) {
        setupDragAndDropForElement(DOM.fileUploadContainer, false);
    }
    
    // Configurar para modo m√∫ltiple
    if (DOM.multipleFileUploadContainer) {
        setupDragAndDropForElement(DOM.multipleFileUploadContainer, true);
    }
    
    console.log('‚úÖ Drag and drop configurado');
}

function setupDragAndDropForElement(element, isMultiple) {
    element.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.add('upload__container--dragover');
    });
    
    element.addEventListener('dragleave', function() {
        this.classList.remove('upload__container--dragover');
    });
    
    element.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('upload__container--dragover');
        
        if (e.dataTransfer.files.length) {
            console.log(`üìÅ ${e.dataTransfer.files.length} archivo(s) arrastrado(s)`);
            
            if (isMultiple) {
                handleMultipleFiles(Array.from(e.dataTransfer.files));
            } else {
                if (e.dataTransfer.files.length > 1) {
                    showAlert('Para subir m√∫ltiples archivos, cambia al modo "Subir M√∫ltiple"', 'warning');
                    return;
                }
                handleFile(e.dataTransfer.files[0]);
            }
        }
    });
}

// =============================================================================
// MANEJO DE ARCHIVOS INDIVIDUALES
// =============================================================================
function handleFile(file) {
    if (!file) {
        console.warn('‚ö†Ô∏è No se proporcion√≥ archivo');
        return;
    }
    
    console.group(`üìã Procesando archivo individual: ${file.name}`);
    
    // Validar archivo
    const fileExtension = file.name.split('.').pop().toLowerCase();
    if (!CONFIG.ALLOWED_FILE_TYPES.includes(fileExtension)) {
        showAlert(`Tipo de archivo no permitido. Formatos aceptados: ${CONFIG.ALLOWED_FILE_TYPES.join(', ').toUpperCase()}`, 'error');
        console.groupEnd();
        return;
    }
    
    if (file.size > CONFIG.MAX_FILE_SIZE) {
        showAlert(`El archivo excede el tama√±o m√°ximo permitido (${formatFileSize(CONFIG.MAX_FILE_SIZE)})`, 'error');
        console.groupEnd();
        return;
    }
    
    // Guardar archivo en estado
    window.appState.selectedFile = file;
    
    // Mostrar informaci√≥n
    DOM.fileName.textContent = file.name;
    DOM.fileSize.textContent = formatFileSize(file.size);
    DOM.fileInfo.style.display = 'block';
    DOM.uploadDocumentBtn.disabled = false;
    
    console.log('‚úÖ Archivo individual validado correctamente');
    console.groupEnd();
}

// =============================================================================
// MANEJO DE M√öLTIPLES ARCHIVOS - NUEVO
// =============================================================================
function handleMultipleFiles(files) {
    console.group(`üìÅ Procesando ${files.length} archivo(s) m√∫ltiple(s)`);
    
    // Validar cantidad m√°xima
    if (files.length > CONFIG.MAX_MULTIPLE_FILES) {
        showAlert(`M√°ximo ${CONFIG.MAX_MULTIPLE_FILES} archivos permitidos. Seleccionados: ${files.length}`, 'error');
        console.groupEnd();
        return;
    }
    
    // Agregar archivos al estado
    multipleUploadState.addFiles(files);
    
    // Actualizar UI
    updateMultipleUploadUI();
    
    // Habilitar bot√≥n de subida si hay archivos
    if (multipleUploadState.files.length > 0) {
        DOM.uploadMultipleDocumentsBtn.disabled = false;
        DOM.uploadMultipleDocumentsBtn.querySelector('#uploadCount').textContent = multipleUploadState.files.length;
    }
    
    console.log(`‚úÖ ${files.length} archivo(s) procesado(s)`);
    console.groupEnd();
}

function updateMultipleUploadUI() {
    console.log('üîÑ Actualizando UI de subida m√∫ltiple');
    
    // Actualizar contador
    DOM.selectedFilesCount.textContent = multipleUploadState.files.length;
    
    // Actualizar lista de archivos
    renderFilesList();
    
    // Actualizar resumen
    updateFilesSummary();
    
    // Actualizar configuraci√≥n com√∫n
    updateCommonSettings();
}

function renderFilesList() {
    console.log('üìã Renderizando lista de archivos');
    
    if (!DOM.filesListContainer) {
        console.error('‚ùå Contenedor de lista no encontrado');
        return;
    }
    
    // Limpiar lista
    DOM.filesListContainer.innerHTML = '';
    
    if (multipleUploadState.files.length === 0) {
        DOM.filesListContainer.innerHTML = `
            <div class="files__empty">
                <i class="fas fa-file-alt"></i>
                <p>No hay archivos seleccionados</p>
            </div>
        `;
        return;
    }
    
    // Renderizar cada archivo
    multipleUploadState.files.forEach(fileObj => {
        const file = fileObj.file;
        const fileElement = createFileElement(fileObj);
        DOM.filesListContainer.appendChild(fileElement);
    });
}

function createFileElement(fileObj) {
    const file = fileObj.file;
    const fileExtension = file.name.split('.').pop().toLowerCase();
    const fileIcon = getFileIcon(fileExtension);
    
    const element = document.createElement('div');
    element.className = `file-item file-item--${fileObj.status}`;
    element.dataset.fileId = fileObj.id;
    
    element.innerHTML = `
        <div class="file-item__header">
            <div class="file-item__icon">
                <i class="fas fa-file-${fileIcon}"></i>
            </div>
            <div class="file-item__info">
                <div class="file-item__name" title="${file.name}">${file.name}</div>
                <div class="file-item__details">
                    <span class="file-item__size">${formatFileSize(file.size)}</span>
                    <span class="file-item__type">${fileExtension.toUpperCase()}</span>
                </div>
            </div>
            <div class="file-item__actions">
                <button class="btn btn--sm btn--outline file-item__edit" title="Editar configuraci√≥n">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn--sm btn--danger file-item__remove" title="Eliminar">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
        
        <div class="file-item__body">
            <!-- Estado y progreso -->
            <div class="file-item__status">
                <span class="status-badge status-badge--${fileObj.status}">
                    ${getStatusText(fileObj.status)}
                </span>
                ${fileObj.status === 'uploading' ? `
                    <div class="file-item__progress">
                        <div class="progress-bar">
                            <div class="progress-bar__fill" style="width: ${fileObj.progress}%"></div>
                        </div>
                        <span class="progress-text">${fileObj.progress}%</span>
                    </div>
                ` : ''}
            </div>
            
            <!-- Configuraci√≥n personalizada (colapsable) -->
            <div class="file-item__config" style="display: none;">
                <div class="form__group form__group--sm">
                    <label class="form__label">Descripci√≥n</label>
                    <textarea class="form__textarea form__textarea--sm file-item__description" 
                              rows="2" placeholder="Descripci√≥n del archivo">${fileObj.description || ''}</textarea>
                </div>
                
                <div class="form__row">
                    <div class="form__group form__group--sm">
                        <label class="form__label">Categor√≠a</label>
                        <select class="form__select form__select--sm file-item__category">
                            <option value="">Usar categor√≠a com√∫n</option>
                        </select>
                    </div>
                    <div class="form__group form__group--sm">
                        <label class="form__label">Fecha Vencimiento</label>
                        <input type="date" class="form__input form__input--sm file-item__expiration"
                               value="${fileObj.customExpirationDate || ''}">
                    </div>
                </div>
            </div>
        </div>
        
        ${fileObj.error ? `
            <div class="file-item__error">
                <i class="fas fa-exclamation-circle"></i>
                <span>${fileObj.error}</span>
            </div>
        ` : ''}
    `;
    
    // Agregar event listeners
    const editBtn = element.querySelector('.file-item__edit');
    const removeBtn = element.querySelector('.file-item__remove');
    const configSection = element.querySelector('.file-item__config');
    
    editBtn.addEventListener('click', () => {
        configSection.style.display = configSection.style.display === 'none' ? 'block' : 'none';
        populateFileCategorySelect(element.querySelector('.file-item__category'));
    });
    
    removeBtn.addEventListener('click', () => {
        if (multipleUploadState.removeFile(fileObj.id)) {
            updateMultipleUploadUI();
            DOM.uploadMultipleDocumentsBtn.querySelector('#uploadCount').textContent = multipleUploadState.files.length;
            
            if (multipleUploadState.files.length === 0) {
                DOM.uploadMultipleDocumentsBtn.disabled = true;
            }
        }
    });
    
    // Actualizar campos cuando cambian
    const descriptionField = element.querySelector('.file-item__description');
    const categoryField = element.querySelector('.file-item__category');
    const expirationField = element.querySelector('.file-item__expiration');
    
    descriptionField.addEventListener('change', (e) => {
        fileObj.description = e.target.value;
    });
    
    categoryField.addEventListener('change', (e) => {
        fileObj.customCategory = e.target.value;
    });
    
    expirationField.addEventListener('change', (e) => {
        fileObj.customExpirationDate = e.target.value;
    });
    
    return element;
}

function getStatusText(status) {
    const statusMap = {
        'pending': 'Pendiente',
        'uploading': 'Subiendo',
        'completed': 'Completado',
        'failed': 'Fallido'
    };
    return statusMap[status] || status;
}

function updateFilesSummary() {
    console.log('üìä Actualizando resumen de archivos');
    
    if (!DOM.filesSummary) return;
    
    const stats = multipleUploadState.getStats();
    
    // Calcular tiempo estimado (1MB ‚âà 1 segundo en conexi√≥n buena)
    const estimatedTimeSeconds = Math.ceil(stats.totalSize / (1024 * 1024));
    
    DOM.filesSummary.innerHTML = `
        <div class="summary__item">
            <i class="fas fa-file"></i>
            <span>Total archivos: <strong>${stats.total}</strong></span>
        </div>
        <div class="summary__item">
            <i class="fas fa-hdd"></i>
            <span>Tama√±o total: <strong>${formatFileSize(stats.totalSize)}</strong></span>
        </div>
        <div class="summary__item">
            <i class="fas fa-clock"></i>
            <span>Tiempo estimado: <strong>${estimatedTimeSeconds}s</strong></span>
        </div>
    `;
}

function updateCommonSettings() {
    console.log('‚öôÔ∏è Actualizando configuraci√≥n com√∫n');
    
    // Actualizar estado con valores de los selects
    multipleUploadState.commonCategory = DOM.multipleDocumentCategory.value;
    multipleUploadState.commonPersonId = DOM.multipleDocumentPerson.value;
    multipleUploadState.expirationDays = DOM.multipleExpirationDays.value ? parseInt(DOM.multipleExpirationDays.value) : null;
    
    // Actualizar estrategia
    multipleUploadState.uploadStrategy = DOM.uploadStrategy.value;
    
    // Actualizar opciones avanzadas
    multipleUploadState.autoGenerateDescriptions = DOM.autoGenerateDescriptions?.checked || true;
    multipleUploadState.notifyPerson = DOM.notifyPerson?.checked || false;
}

// =============================================================================
// SUBIDA DE DOCUMENTOS INDIVIDUAL
// =============================================================================
async function handleUploadDocument() {
    console.group('üì§ Subiendo documento individual');
    
    if (!window.appState.selectedFile) {
        showAlert('Por favor selecciona un archivo', 'error');
        console.groupEnd();
        return;
    }
    
    if (!DOM.documentCategory.value) {
        showAlert('Por favor selecciona una categor√≠a', 'error');
        console.groupEnd();
        return;
    }
    
    try {
        setLoadingState(true, DOM.uploadDocumentBtn);
        
        console.log('üìã Iniciando upload del documento...');
        console.log('üìã Archivo:', window.appState.selectedFile.name);
        console.log('üìã Tama√±o:', formatFileSize(window.appState.selectedFile.size));
        
        const formData = new FormData();
        formData.append('file', window.appState.selectedFile);
        formData.append('descripcion', DOM.documentDescription.value);
        formData.append('categoria', DOM.documentCategory.value);
        formData.append('fecha_vencimiento', DOM.documentExpiration.value);
        formData.append('persona_id', DOM.documentPerson.value);

        console.log('üì§ Enviando al servidor...');

        const response = await fetch(`${CONFIG.API_BASE_URL}/documents`, {
            method: 'POST',
            body: formData
        });

        console.log('üì• Respuesta:', response.status);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Error del servidor:', errorText);
            throw new Error(`Error del servidor (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        console.log('üì¶ Datos de respuesta:', data);

        if (data.success) {
            showAlert(data.message, 'success');
            await loadDocuments();
            closeDocumentModal();
            
            if (window.appState.currentTab === 'dashboard') {
                await window.loadDashboardData();
            }
        } else {
            throw new Error(data.message || 'Error desconocido');
        }
        
    } catch (error) {
        console.error('‚ùå Error subiendo documento:', error);
        showAlert('Error al subir documento: ' + error.message, 'error');
    } finally {
        setLoadingState(false, DOM.uploadDocumentBtn);
        console.groupEnd();
    }
}

// =============================================================================
// SUBIDA M√öLTIPLE DE DOCUMENTOS - NUEVO
// =============================================================================
async function handleUploadMultipleDocuments() {
    console.group('üì§üì§üì§ SUBIDA M√öLTIPLE DE DOCUMENTOS');
    
    try {
        // Validar antes de empezar
        updateCommonSettings();
        
        if (!multipleUploadState.validateAllFiles()) {
            console.error('‚ùå Validaci√≥n fallida');
            console.groupEnd();
            return;
        }
        
        console.log('üöÄ Iniciando subida m√∫ltiple...');
        multipleUploadState.logState();
        
        // Configurar estado
        multipleUploadState.isUploading = true;
        DOM.uploadMultipleDocumentsBtn.disabled = true;
        DOM.uploadMultipleDocumentsBtn.innerHTML = '<div class="spinner spinner--sm"></div> Preparando...';
        
        // Mostrar contenedor de progreso
        showUploadProgressContainer();
        
        // Iniciar subida seg√∫n estrategia
        const strategy = DOM.uploadStrategy.value;
        console.log(`üîÑ Usando estrategia: ${strategy}`);
        
        let result;
        switch(strategy) {
            case 'sequential':
                result = await uploadSequentially();
                break;
            case 'parallel':
                result = await uploadInParallel();
                break;
            case 'batch':
                result = await uploadInBatches();
                break;
            default:
                result = await uploadSequentially();
        }
        
        // Mostrar resultados
        showUploadResults(result);
        
        // Recargar documentos si hubo √©xito
        if (result.successCount > 0) {
            await loadDocuments();
            
            if (window.appState.currentTab === 'dashboard') {
                await window.loadDashboardData();
            }
        }
        
        console.log('‚úÖ Subida m√∫ltiple completada');
        console.groupEnd();
        
    } catch (error) {
        console.error('‚ùå Error en subida m√∫ltiple:', error);
        showAlert('Error en subida m√∫ltiple: ' + error.message, 'error');
    } finally {
        // Resetear estado
        multipleUploadState.isUploading = false;
        DOM.uploadMultipleDocumentsBtn.disabled = false;
        DOM.uploadMultipleDocumentsBtn.innerHTML = `
            <i class="fas fa-layer-group"></i> 
            Subir Todos (<span id="uploadCount">${multipleUploadState.files.length}</span>)
        `;
        
        // Ocultar progreso despu√©s de un tiempo
        setTimeout(() => {
            hideUploadProgressContainer();
        }, 5000);
    }
}

async function uploadSequentially() {
    console.log('üîÄ Subida secuencial iniciada');
    
    const results = {
        successCount: 0,
        failureCount: 0,
        totalTime: 0,
        uploadedFiles: []
    };
    
    const startTime = Date.now();
    
    for (let i = 0; i < multipleUploadState.files.length; i++) {
        const fileObj = multipleUploadState.files[i];
        
        try {
            // Actualizar estado
            fileObj.status = 'uploading';
            fileObj.progress = 0;
            updateFileUI(fileObj.id);
            
            console.log(`üì§ Subiendo archivo ${i + 1}/${multipleUploadState.files.length}: ${fileObj.file.name}`);
            
            // Subir archivo
            const success = await uploadSingleFileWithProgress(fileObj);
            
            if (success) {
                results.successCount++;
                fileObj.status = 'completed';
                fileObj.progress = 100;
                results.uploadedFiles.push(fileObj.file.name);
                
                console.log(`‚úÖ Archivo subido: ${fileObj.file.name}`);
                showAlert(`‚úÖ ${fileObj.file.name} - Subido correctamente`, 'success');
            } else {
                results.failureCount++;
                fileObj.status = 'failed';
                fileObj.error = 'Error en la subida';
                
                console.error(`‚ùå Error subiendo: ${fileObj.file.name}`);
                showAlert(`‚ùå ${fileObj.file.name} - Error en la subida`, 'error');
            }
            
            updateFileUI(fileObj.id);
            
            // Peque√±a pausa entre archivos (excepto el √∫ltimo)
            if (i < multipleUploadState.files.length - 1) {
                await new Promise(resolve => setTimeout(resolve, CONFIG.UPLOAD_STRATEGIES.SEQUENTIAL.delayBetween));
            }
            
        } catch (error) {
            console.error(`‚ùå Error cr√≠tico en archivo ${fileObj.file.name}:`, error);
            results.failureCount++;
            fileObj.status = 'failed';
            fileObj.error = error.message;
            updateFileUI(fileObj.id);
        }
    }
    
    results.totalTime = Date.now() - startTime;
    console.log(`‚è±Ô∏è  Tiempo total secuencial: ${results.totalTime}ms`);
    
    return results;
}

async function uploadInParallel() {
    console.log('‚ö° Subida paralela iniciada');
    
    const maxConcurrent = CONFIG.UPLOAD_STRATEGIES.PARALLEL.maxConcurrent;
    const results = {
        successCount: 0,
        failureCount: 0,
        totalTime: 0,
        uploadedFiles: []
    };
    
    const startTime = Date.now();
    
    // Crear array de promesas
    const uploadPromises = [];
    const activeUploads = new Set();
    
    for (let i = 0; i < multipleUploadState.files.length; i++) {
        const fileObj = multipleUploadState.files[i];
        
        // Esperar si hay demasiadas subidas concurrentes
        while (activeUploads.size >= maxConcurrent) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Iniciar subida
        fileObj.status = 'uploading';
        fileObj.progress = 0;
        updateFileUI(fileObj.id);
        
        activeUploads.add(fileObj.id);
        
        const uploadPromise = uploadSingleFileWithProgress(fileObj)
            .then(success => {
                if (success) {
                    results.successCount++;
                    fileObj.status = 'completed';
                    fileObj.progress = 100;
                    results.uploadedFiles.push(fileObj.file.name);
                    console.log(`‚úÖ ${fileObj.file.name} - Completado`);
                } else {
                    results.failureCount++;
                    fileObj.status = 'failed';
                    fileObj.error = 'Error en la subida';
                    console.error(`‚ùå ${fileObj.file.name} - Fallado`);
                }
                
                updateFileUI(fileObj.id);
                activeUploads.delete(fileObj.id);
                
                return success;
            })
            .catch(error => {
                console.error(`‚ùå Error en ${fileObj.file.name}:`, error);
                results.failureCount++;
                fileObj.status = 'failed';
                fileObj.error = error.message;
                updateFileUI(fileObj.id);
                activeUploads.delete(fileObj.id);
                return false;
            });
        
        uploadPromises.push(uploadPromise);
    }
    
    // Esperar a que todas las subidas terminen
    await Promise.all(uploadPromises);
    
    results.totalTime = Date.now() - startTime;
    console.log(`‚è±Ô∏è  Tiempo total paralelo: ${results.totalTime}ms`);
    
    return results;
}

async function uploadInBatches() {
    console.log('üì¶ Subida por lotes iniciada');
    
    const batchSize = CONFIG.MULTIPLE_UPLOAD.BATCH_SIZE;
    const delayBetween = CONFIG.UPLOAD_STRATEGIES.BATCH.delayBetween;
    const results = {
        successCount: 0,
        failureCount: 0,
        totalTime: 0,
        uploadedFiles: []
    };
    
    const startTime = Date.now();
    
    // Dividir archivos en lotes
    const batches = [];
    for (let i = 0; i < multipleUploadState.files.length; i += batchSize) {
        batches.push(multipleUploadState.files.slice(i, i + batchSize));
    }
    
    console.log(`üìä ${batches.length} lotes creados (tama√±o: ${batchSize})`);
    
    // Procesar cada lote
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batch = batches[batchIndex];
        console.log(`üì§ Procesando lote ${batchIndex + 1}/${batches.length}`);
        
        // Subir archivos del lote en paralelo
        const batchPromises = batch.map(fileObj => {
            fileObj.status = 'uploading';
            fileObj.progress = 0;
            updateFileUI(fileObj.id);
            
            return uploadSingleFileWithProgress(fileObj)
                .then(success => {
                    if (success) {
                        results.successCount++;
                        fileObj.status = 'completed';
                        fileObj.progress = 100;
                        results.uploadedFiles.push(fileObj.file.name);
                        console.log(`‚úÖ ${fileObj.file.name} - Completado`);
                    } else {
                        results.failureCount++;
                        fileObj.status = 'failed';
                        fileObj.error = 'Error en la subida';
                        console.error(`‚ùå ${fileObj.file.name} - Fallado`);
                    }
                    
                    updateFileUI(fileObj.id);
                    return success;
                })
                .catch(error => {
                    console.error(`‚ùå Error en ${fileObj.file.name}:`, error);
                    results.failureCount++;
                    fileObj.status = 'failed';
                    fileObj.error = error.message;
                    updateFileUI(fileObj.id);
                    return false;
                });
        });
        
        // Esperar a que termine el lote
        await Promise.all(batchPromises);
        
        // Pausa entre lotes (excepto el √∫ltimo)
        if (batchIndex < batches.length - 1) {
            console.log(`‚è∏Ô∏è  Pausa entre lotes: ${delayBetween}ms`);
            await new Promise(resolve => setTimeout(resolve, delayBetween));
        }
    }
    
    results.totalTime = Date.now() - startTime;
    console.log(`‚è±Ô∏è  Tiempo total por lotes: ${results.totalTime}ms`);
    
    return results;
}

async function uploadSingleFileWithProgress(fileObj) {
    return new Promise(async (resolve, reject) => {
        try {
            console.log(`üì§ Preparando subida: ${fileObj.file.name}`);
            
            // Preparar FormData
            const formData = new FormData();
            formData.append('file', fileObj.file);
            
            // Determinar descripci√≥n
            let description = fileObj.description;
            if (!description && multipleUploadState.autoGenerateDescriptions) {
                description = fileObj.file.name.replace(/\.[^/.]+$/, "");
            }
            formData.append('descripcion', description || '');
            
            // Determinar categor√≠a
            const categoria = fileObj.customCategory || multipleUploadState.commonCategory;
            if (!categoria) {
                throw new Error('Categor√≠a no definida');
            }
            formData.append('categoria', categoria);
            
            // Determinar persona
            const persona_id = fileObj.customPersonId || multipleUploadState.commonPersonId;
            if (persona_id) {
                formData.append('persona_id', persona_id);
            }
            
            // Determinar fecha de vencimiento
            let fecha_vencimiento = fileObj.customExpirationDate;
            if (!fecha_vencimiento && multipleUploadState.expirationDays) {
                const expirationDate = new Date();
                expirationDate.setDate(expirationDate.getDate() + multipleUploadState.expirationDays);
                fecha_vencimiento = expirationDate.toISOString().split('T')[0];
            }
            if (fecha_vencimiento) {
                formData.append('fecha_vencimiento', fecha_vencimiento);
            }
            
            // Configurar notificaci√≥n
            if (multipleUploadState.notifyPerson && persona_id) {
                formData.append('notificar', 'true');
            }
            
            console.log(`üìã Configuraci√≥n para ${fileObj.file.name}:`, {
                descripcion: description,
                categoria: categoria,
                persona_id: persona_id,
                fecha_vencimiento: fecha_vencimiento
            });
            
            // Crear XMLHttpRequest para tener progreso
            const xhr = new XMLHttpRequest();
            
            // Configurar eventos de progreso
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const percentComplete = Math.round((e.loaded / e.total) * 100);
                    fileObj.progress = percentComplete;
                    updateFileUI(fileObj.id);
                    
                    if (CONFIG.DEBUG.LOG_UPLOAD_PROGRESS) {
                        console.log(`üìà ${fileObj.file.name}: ${percentComplete}%`);
                    }
                }
            });
            
            xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        if (response.success) {
                            console.log(`‚úÖ ${fileObj.file.name} - Subida exitosa`);
                            resolve(true);
                        } else {
                            console.error(`‚ùå ${fileObj.file.name} - Error del servidor:`, response.message);
                            fileObj.error = response.message;
                            resolve(false);
                        }
                    } catch (parseError) {
                        console.error(`‚ùå ${fileObj.file.name} - Error parseando respuesta:`, parseError);
                        fileObj.error = 'Error en la respuesta del servidor';
                        resolve(false);
                    }
                } else {
                    console.error(`‚ùå ${fileObj.file.name} - HTTP ${xhr.status}: ${xhr.statusText}`);
                    fileObj.error = `Error HTTP ${xhr.status}`;
                    resolve(false);
                }
            });
            
            xhr.addEventListener('error', () => {
                console.error(`‚ùå ${fileObj.file.name} - Error de red`);
                fileObj.error = 'Error de conexi√≥n';
                resolve(false);
            });
            
            xhr.addEventListener('abort', () => {
                console.warn(`‚ö†Ô∏è ${fileObj.file.name} - Subida cancelada`);
                fileObj.error = 'Subida cancelada';
                resolve(false);
            });
            
            // Enviar la petici√≥n
            xhr.open('POST', `${CONFIG.API_BASE_URL}/documents`);
            xhr.send(formData);
            
        } catch (error) {
            console.error(`‚ùå Error preparando ${fileObj.file.name}:`, error);
            fileObj.error = error.message;
            resolve(false);
        }
    });
}

function updateFileUI(fileId) {
    const fileElement = document.querySelector(`.file-item[data-file-id="${fileId}"]`);
    if (!fileElement) return;
    
    const fileObj = multipleUploadState.files.find(f => f.id === fileId);
    if (!fileObj) return;
    
    // Actualizar clase de estado
    fileElement.className = `file-item file-item--${fileObj.status}`;
    
    // Actualizar badge de estado
    const statusBadge = fileElement.querySelector('.status-badge');
    if (statusBadge) {
        statusBadge.className = `status-badge status-badge--${fileObj.status}`;
        statusBadge.textContent = getStatusText(fileObj.status);
    }
    
    // Actualizar barra de progreso
    const progressBar = fileElement.querySelector('.progress-bar__fill');
    const progressText = fileElement.querySelector('.progress-text');
    
    if (progressBar && fileObj.status === 'uploading') {
        progressBar.style.width = `${fileObj.progress}%`;
        if (progressText) {
            progressText.textContent = `${fileObj.progress}%`;
        }
    }
    
    // Mostrar/ocultar secci√≥n de error
    const errorSection = fileElement.querySelector('.file-item__error');
    if (errorSection) {
        if (fileObj.error) {
            errorSection.style.display = 'flex';
            errorSection.querySelector('span').textContent = fileObj.error;
        } else {
            errorSection.style.display = 'none';
        }
    }
    
    // Actualizar resumen global
    updateOverallProgress();
}

function updateOverallProgress() {
    const stats = multipleUploadState.getStats();
    const progressContainer = document.getElementById('uploadProgressContainer');
    
    if (!progressContainer) return;
    
    const totalFiles = stats.total;
    const completedFiles = stats.completed;
    const progressPercent = totalFiles > 0 ? Math.round((completedFiles / totalFiles) * 100) : 0;
    
    // Actualizar barra de progreso principal
    const overallProgressBar = progressContainer.querySelector('.overall-progress__bar-fill');
    const overallProgressText = progressContainer.querySelector('.overall-progress__text');
    
    if (overallProgressBar) {
        overallProgressBar.style.width = `${progressPercent}%`;
    }
    
    if (overallProgressText) {
        overallProgressText.textContent = `${completedFiles}/${totalFiles} archivos (${progressPercent}%)`;
    }
    
    // Actualizar estad√≠sticas
    const statsElement = progressContainer.querySelector('.upload-stats');
    if (statsElement) {
        statsElement.innerHTML = `
            <div class="stat-item">
                <span class="stat-item__label">Completados:</span>
                <span class="stat-item__value stat-item__value--success">${stats.completed}</span>
            </div>
            <div class="stat-item">
                <span class="stat-item__label">Fallidos:</span>
                <span class="stat-item__value stat-item__value--danger">${stats.failed}</span>
            </div>
            <div class="stat-item">
                <span class="stat-item__label">Subiendo:</span>
                <span class="stat-item__value stat-item__value--info">${stats.uploading}</span>
            </div>
            <div class="stat-item">
                <span class="stat-item__label">Tama√±o:</span>
                <span class="stat-item__value">${formatFileSize(stats.uploadedSize)} / ${formatFileSize(stats.totalSize)}</span>
            </div>
        `;
    }
}

function showUploadProgressContainer() {
    console.log('üìä Mostrando contenedor de progreso');
    
    // Crear contenedor si no existe
    let progressContainer = document.getElementById('uploadProgressContainer');
    if (!progressContainer) {
        progressContainer = document.createElement('div');
        progressContainer.id = 'uploadProgressContainer';
        progressContainer.className = 'upload-progress';
        
        progressContainer.innerHTML = `
            <div class="upload-progress__header">
                <h4><i class="fas fa-layer-group"></i> Subida M√∫ltiple en Progreso</h4>
                <button class="btn btn--sm btn--outline" id="cancelUploadBtn">
                    <i class="fas fa-times"></i> Cancelar
                </button>
            </div>
            
            <div class="upload-progress__body">
                <div class="overall-progress">
                    <div class="overall-progress__bar">
                        <div class="overall-progress__bar-fill" style="width: 0%"></div>
                    </div>
                    <div class="overall-progress__text">0/0 archivos (0%)</div>
                </div>
                
                <div class="upload-stats">
                    <!-- Las estad√≠sticas se actualizar√°n din√°micamente -->
                </div>
                
                <div class="current-uploads" id="currentUploadsList">
                    <!-- Las subidas actuales se mostrar√°n aqu√≠ -->
                </div>
            </div>
            
            <div class="upload-progress__footer">
                <div class="upload-speed">
                    <i class="fas fa-tachometer-alt"></i>
                    <span>Velocidad: <span id="uploadSpeed">Calculando...</span></span>
                </div>
                <div class="upload-time">
                    <i class="fas fa-clock"></i>
                    <span>Tiempo: <span id="uploadTime">0s</span></span>
                </div>
            </div>
        `;
        
        // Agregar al body
        document.body.appendChild(progressContainer);
        
        // Agregar event listener para cancelar
        const cancelBtn = document.getElementById('cancelUploadBtn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', cancelMultipleUpload);
        }
    }
    
    // Mostrar contenedor
    progressContainer.style.display = 'block';
    
    // Posicionar
    progressContainer.style.position = 'fixed';
    progressContainer.style.bottom = '20px';
    progressContainer.style.right = '20px';
    progressContainer.style.zIndex = '9999';
    
    // Iniciar actualizaci√≥n de tiempo
    startUploadTimer();
}

function hideUploadProgressContainer() {
    const progressContainer = document.getElementById('uploadProgressContainer');
    if (progressContainer) {
        progressContainer.style.display = 'none';
    }
}

function startUploadTimer() {
    const startTime = Date.now();
    const timeElement = document.getElementById('uploadTime');
    
    const timer = setInterval(() => {
        if (!multipleUploadState.isUploading) {
            clearInterval(timer);
            return;
        }
        
        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
        if (timeElement) {
            timeElement.textContent = `${elapsedSeconds}s`;
        }
    }, 1000);
}

function cancelMultipleUpload() {
    console.log('‚èπÔ∏è Cancelando subida m√∫ltiple...');
    
    if (confirm('¬øEst√°s seguro de que deseas cancelar la subida m√∫ltiple?')) {
        multipleUploadState.isUploading = false;
        
        // Cancelar todas las subidas pendientes
        multipleUploadState.files.forEach(fileObj => {
            if (fileObj.status === 'uploading' || fileObj.status === 'pending') {
                fileObj.status = 'failed';
                fileObj.error = 'Subida cancelada por el usuario';
                updateFileUI(fileObj.id);
            }
        });
        
        showAlert('Subida m√∫ltiple cancelada', 'warning');
        hideUploadProgressContainer();
    }
}

function showUploadResults(results) {
    console.group('üìä Resultados de la subida m√∫ltiple');
    console.table({
        'Archivos exitosos': results.successCount,
        'Archivos fallidos': results.failureCount,
        'Tiempo total': `${results.totalTime}ms`,
        'Archivos subidos': results.uploadedFiles.join(', ')
    });
    console.groupEnd();
    
    // Mostrar notificaci√≥n con resultados
    if (results.successCount > 0 && results.failureCount === 0) {
        showAlert(`‚úÖ Todos los ${results.successCount} archivos se subieron correctamente`, 'success');
    } else if (results.successCount > 0) {
        showAlert(
            `‚ö†Ô∏è ${results.successCount} archivos subidos, ${results.failureCount} fallidos. ` +
            `Revisa la lista para m√°s detalles.`,
            'warning'
        );
    } else {
        showAlert(
            `‚ùå Todos los ${results.failureCount} archivos fallaron. ` +
            `Revisa la lista para m√°s detalles.`,
            'error'
        );
    }
    
    // Si todos fallaron, mantener los archivos en la lista
    if (results.successCount > 0) {
        // Remover archivos exitosos
        multipleUploadState.files = multipleUploadState.files.filter(f => f.status !== 'completed');
        updateMultipleUploadUI();
        
        if (multipleUploadState.files.length === 0) {
            // Cerrar modal si no quedan archivos
            setTimeout(() => {
                closeDocumentModal();
            }, 2000);
        }
    }
}

// =============================================================================
// FUNCIONES AUXILIARES
// =============================================================================
function handleFileSelect(e) {
    console.log('üìÅ Archivo individual seleccionado:', e.target.files[0]?.name);
    handleFile(e.target.files[0]);
}

function handleMultipleFileSelect(e) {
    console.log('üìÅ M√∫ltiples archivos seleccionados:', e.target.files.length);
    handleMultipleFiles(Array.from(e.target.files));
}

function populateDocumentCategorySelect() {
    if (!DOM.documentCategory) return;
    
    DOM.documentCategory.innerHTML = '<option value="">Seleccionar categor√≠a</option>';
    
    if (window.appState && window.appState.categories) {
        window.appState.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.nombre;
            option.textContent = category.nombre;
            DOM.documentCategory.appendChild(option);
        });
    }
}

function populateMultipleCategorySelect() {
    if (!DOM.multipleDocumentCategory) return;
    
    DOM.multipleDocumentCategory.innerHTML = '<option value="">Seleccionar categor√≠a com√∫n</option>';
    
    if (window.appState && window.appState.categories) {
        window.appState.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.nombre;
            option.textContent = category.nombre;
            DOM.multipleDocumentCategory.appendChild(option);
        });
    }
}

function populateFileCategorySelect(selectElement) {
    if (!selectElement) return;
    
    selectElement.innerHTML = '<option value="">Usar categor√≠a com√∫n</option>';
    
    if (window.appState && window.appState.categories) {
        window.appState.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.nombre;
            option.textContent = category.nombre;
            selectElement.appendChild(option);
        });
    }
}

// =============================================================================
// FUNCIONES DE DESCARGA (MANTENER LAS EXISTENTES)
// =============================================================================
async function downloadDocument(id) {
    console.group('üöÄ DESCARGAR DOCUMENTO');
    
    try {
        // Verificar que estamos en un navegador
        if (typeof window === 'undefined' || typeof document === 'undefined') {
            throw new Error('Este m√©todo solo funciona en el navegador');
        }
        
        // Buscar documento
        const doc = window.appState.documents.find(d => d._id === id);
        if (!doc) {
            throw new Error('Documento no encontrado');
        }
        
        const fileName = doc.nombre_original;
        
        console.log('üìÑ Descargando:', {
            id: id,
            nombre: fileName,
            tipo: doc.tipo_archivo
        });
        
        showAlert(`Iniciando descarga: ${fileName}`, 'info');
        
        // URL del endpoint
        const endpoint = `${CONFIG.API_BASE_URL}/documents/${id}/download`;
        
        // Agregar par√°metros para evitar cach√©
        const url = new URL(endpoint);
        url.searchParams.append('t', Date.now());
        url.searchParams.append('filename', fileName);
        
        const finalUrl = url.toString();
        console.log('üîó URL final:', finalUrl);
        
        // M√©todo: Enlace temporal
        const link = document.createElement('a');
        link.href = finalUrl;
        link.download = fileName;
        
        // Para documentos no-imagen, abrir en nueva pesta√±a
        const fileExtension = fileName.split('.').pop().toLowerCase();
        const isImage = ['png', 'jpg', 'jpeg', 'gif'].includes(fileExtension);
        
        if (!isImage) {
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
        }
        
        link.style.display = 'none';
        document.body.appendChild(link);
        
        // Hacer clic
        link.click();
        
        // Limpiar despu√©s de 3 segundos
        setTimeout(() => {
            if (link.parentNode) {
                document.body.removeChild(link);
            }
        }, 3000);
        
        console.log('‚úÖ Descarga iniciada');
        showAlert(`Descarga iniciada: ${fileName}`, 'success');
        
        // Tambi√©n abrir en nueva pesta√±a como respaldo
        setTimeout(() => {
            window.open(finalUrl, '_blank');
        }, 100);
        
        console.groupEnd();
        return true;
        
    } catch (error) {
        console.error('‚ùå Error en descarga:', error);
        
        // Mostrar error espec√≠fico
        let errorMessage = `Error: ${error.message}`;
        
        if (error.message.includes('document is not defined')) {
            errorMessage = 'Error del navegador. Intenta recargar la p√°gina.';
        } else if (error.message.includes('fetch') || error.message.includes('network')) {
            errorMessage = 'Error de red. Verifica tu conexi√≥n a internet.';
        }
        
        showAlert(errorMessage, 'error');
        console.groupEnd();
        return false;
    }
}

async function downloadDocumentSimple(id) {
    const doc = window.appState.documents.find(d => d._id === id);
    if (!doc) {
        showAlert('Documento no encontrado', 'error');
        return;
    }
    
    console.log('‚ö° Descarga simple para:', doc.nombre_original);
    
    const url = `${CONFIG.API_BASE_URL}/documents/${id}/download?simple=true&t=${Date.now()}`;
    
    // M√©todo ultra simple: abrir URL
    window.open(url, '_blank');
    
    showAlert(`Descargando: ${doc.nombre_original}`, 'info');
}

async function downloadDocumentAlternative(id) {
    console.group('üîÑ DESCARGAR DOCUMENTO - M√âTODO ALTERNATIVO');
    
    try {
        const doc = window.appState.documents.find(d => d._id === id);
        if (!doc) {
            throw new Error('Documento no encontrado');
        }
        
        const fileName = doc.nombre_original;
        const endpoint = `${CONFIG.API_BASE_URL}/documents/${id}/download`;
        
        console.log('üìÑ Usando m√©todo alternativo para:', fileName);
        showAlert(`Descargando: ${fileName}...`, 'info');
        
        // Crear formulario oculto
        const form = document.createElement('form');
        form.method = 'GET';
        form.action = endpoint;
        form.target = '_blank';
        form.style.display = 'none';
        
        // Agregar par√°metros
        const timestampInput = document.createElement('input');
        timestampInput.type = 'hidden';
        timestampInput.name = 't';
        timestampInput.value = Date.now();
        form.appendChild(timestampInput);
        
        // Agregar al body y enviar
        document.body.appendChild(form);
        form.submit();
        
        // Limpiar
        setTimeout(() => {
            if (form.parentNode) {
                document.body.removeChild(form);
            }
        }, 3000);
        
        console.log('‚úÖ Formulario enviado para descarga');
        console.groupEnd();
        return true;
        
    } catch (error) {
        console.error('‚ùå Error en m√©todo alternativo:', error);
        showAlert(`Error: ${error.message}`, 'error');
        console.groupEnd();
        return false;
    }
}

function previewDocument(id) {
    console.group('üëÅÔ∏è VISTA PREVIA MEJORADA');
    
    try {
        const document = window.appState.documents.find(doc => doc._id === id);
        if (!document) {
            showAlert('Documento no encontrado', 'error');
            console.groupEnd();
            return;
        }
        
        const fileName = document.nombre_original;
        const fileExtension = fileName.split('.').pop().toLowerCase();
        const cloudinaryUrl = document.url_cloudinary || document.cloudinary_url;
        
        console.log('üìã Documento para vista previa:', {
            nombre: fileName,
            extension: fileExtension,
            url: cloudinaryUrl
        });
        
        // Determinar estrategia seg√∫n tipo
        const previewableImages = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp'];
        const previewablePDF = ['pdf'];
        const officeDocuments = ['doc', 'docx', 'xls', 'xlsx'];
        
        if (previewableImages.includes(fileExtension)) {
            // Im√°genes: abrir directamente
            console.log('üñºÔ∏è Vista previa de imagen');
            if (cloudinaryUrl) {
                window.open(cloudinaryUrl, '_blank');
                showAlert('Abriendo imagen en nueva pesta√±a...', 'info');
            }
            
        } else if (previewablePDF.includes(fileExtension)) {
            // PDF: usar endpoint de preview del servidor
            console.log('üìÑ Vista previa de PDF');
            const previewUrl = `${CONFIG.API_BASE_URL}/documents/${id}/preview`;
            window.open(previewUrl, '_blank');
            showAlert('Abriendo PDF en nueva pesta√±a...', 'info');
            
        } else if (officeDocuments.includes(fileExtension)) {
            // Documentos Office: forzar descarga
            console.log('üìù Documento Office, forzando descarga');
            downloadDocument(id);
            
        } else {
            // Otros tipos: intentar abrir directamente
            console.log('‚ùì Tipo desconocido, intentando abrir');
            if (cloudinaryUrl) {
                window.open(cloudinaryUrl, '_blank');
                showAlert('Abriendo documento en nueva pesta√±a...', 'info');
            } else {
                showAlert('No se puede previsualizar este tipo de archivo', 'warning');
            }
        }
        
    } catch (error) {
        console.error('‚ùå Error en vista previa:', error);
        showAlert(`Error: ${error.message}`, 'error');
    } finally {
        console.groupEnd();
    }
}

async function deleteDocument(id) {
    if (!confirm('¬øEst√°s seguro de que deseas eliminar este documento?')) {
        return;
    }
    
    try {
        console.log('üóëÔ∏è Eliminando documento:', id);
        
        const data = await apiCall(`/documents/${id}`, {
            method: 'DELETE'
        });
        
        if (data.success) {
            showAlert(data.message, 'success');
            await loadDocuments();
            
            if (window.appState.currentTab === 'dashboard') {
                await window.loadDashboardData();
            }
        } else {
            throw new Error(data.message);
        }
        
    } catch (error) {
        console.error('‚ùå Error eliminando documento:', error);
        showAlert('Error al eliminar documento: ' + error.message, 'error');
    }
}

// =============================================================================
// FUNCIONES DE DIAGN√ìSTICO
// =============================================================================
async function debugDocumentDownload(id) {
    console.group('üêõ DIAGN√ìSTICO DE DESCARGA');
    
    try {
        const doc = window.appState.documents.find(d => d._id === id);
        if (!doc) {
            console.error('‚ùå Documento no encontrado');
            showAlert('Documento no encontrado', 'error');
            console.groupEnd();
            return;
        }
        
        console.log('üìä INFORMACI√ìN DEL DOCUMENTO:');
        console.table({
            'ID': doc._id,
            'Nombre': doc.nombre_original,
            'Tipo': doc.tipo_archivo,
            'Tama√±o': `${doc.tamano_archivo} bytes (${formatFileSize(doc.tamano_archivo)})`,
            'URL Cloudinary': doc.url_cloudinary || doc.cloudinary_url,
            'Fecha subida': formatDate(doc.fecha_subida)
        });
        
        // Probar diferentes m√©todos
        console.log('üß™ PROBANDO M√âTODOS DE DESCARGA:');
        
        // M√©todo 1: Endpoint directo
        const endpoint = `${CONFIG.API_BASE_URL}/documents/${id}/download`;
        console.log('1Ô∏è‚É£ Endpoint:', endpoint);
        
        // M√©todo 2: URL Cloudinary
        if (doc.url_cloudinary || doc.cloudinary_url) {
            console.log('2Ô∏è‚É£ Cloudinary URL:', doc.url_cloudinary || doc.cloudinary_url);
        }
        
        // Recomendaciones
        console.log('üí° RECOMENDACIONES:');
        const extension = doc.nombre_original.split('.').pop().toLowerCase();
        
        if (['png', 'jpg', 'jpeg', 'gif'].includes(extension)) {
            console.log('   ‚Ä¢ Usar endpoint del servidor o URL directa de Cloudinary');
        } else if (extension === 'pdf') {
            console.log('   ‚Ä¢ Usar endpoint del servidor (/download)');
        } else {
            console.log('   ‚Ä¢ Usar endpoint del servidor siempre');
        }
        
        showAlert(`Diagn√≥stico completado para: ${doc.nombre_original}`, 'info');
        
    } catch (error) {
        console.error('‚ùå Error en diagn√≥stico:', error);
        showAlert('Error en diagn√≥stico: ' + error.message, 'error');
    } finally {
        console.groupEnd();
    }
}

async function testAllDownloads() {
    console.group('üß™ TEST COMPLETO DE DESCARGAS');
    
    if (!window.appState.documents || window.appState.documents.length === 0) {
        showAlert('No hay documentos para probar', 'warning');
        console.groupEnd();
        return;
    }
    
    const testDocuments = window.appState.documents.slice(0, 2); // Probar solo 2
    const results = [];
    
    showAlert(`Iniciando test de ${testDocuments.length} descargas...`, 'info');
    
    for (const doc of testDocuments) {
        console.log(`\nüîç Probando: ${doc.nombre_original}`);
        
        try {
            const startTime = Date.now();
            await downloadDocument(doc._id);
            const endTime = Date.now();
            
            results.push({
                documento: doc.nombre_original,
                tipo: doc.tipo_archivo,
                tama√±o: formatFileSize(doc.tamano_archivo),
                tiempo: `${endTime - startTime}ms`,
                estado: '‚úÖ EXITOSO'
            });
            
            // Esperar entre descargas
            await new Promise(resolve => setTimeout(resolve, 2000));
            
        } catch (error) {
            results.push({
                documento: doc.nombre_original,
                tipo: doc.tipo_archivo,
                tama√±o: formatFileSize(doc.tamano_archivo),
                tiempo: 'N/A',
                estado: `‚ùå FALLIDO: ${error.message}`
            });
        }
    }
    
    // Mostrar resultados
    console.table(results);
    
    const successful = results.filter(r => r.estado.includes('‚úÖ')).length;
    const total = results.length;
    
    console.log(`\nüìä RESULTADO: ${successful}/${total} descargas exitosas`);
    
    if (successful === total) {
        showAlert('‚úÖ Todas las descargas funcionan correctamente', 'success');
    } else if (successful > 0) {
        showAlert(`‚ö†Ô∏è ${successful}/${total} descargas exitosas`, 'warning');
    } else {
        showAlert('‚ùå Todas las descargas fallaron', 'error');
    }
    
    console.groupEnd();
}

// =============================================================================
// DEBUGGING Y DIAGN√ìSTICO DE SUBIDA M√öLTIPLE
// =============================================================================
function debugMultipleUpload() {
    console.group('üêõ DIAGN√ìSTICO DE SUBIDA M√öLTIPLE');
    
    console.log('üìä Estado actual:', {
        modo: window.appState.uploadMode || 'no definido',
        archivosSeleccionados: multipleUploadState.files.length,
        subiendo: multipleUploadState.isUploading,
        tama√±oTotal: formatFileSize(multipleUploadState.totalSize)
    });
    
    console.log('üìã Archivos individuales:');
    multipleUploadState.files.forEach((fileObj, index) => {
        console.log(`${index + 1}. ${fileObj.file.name}`, {
            tama√±o: formatFileSize(fileObj.file.size),
            estado: fileObj.status,
            progreso: fileObj.progress,
            error: fileObj.error,
            categor√≠aPersonalizada: fileObj.customCategory,
            categor√≠aCom√∫n: multipleUploadState.commonCategory
        });
    });
    
    console.log('‚öôÔ∏è Configuraci√≥n com√∫n:', {
        categor√≠a: multipleUploadState.commonCategory,
        persona: multipleUploadState.commonPersonId,
        d√≠asVencimiento: multipleUploadState.expirationDays,
        estrategia: multipleUploadState.uploadStrategy,
        autoDescripciones: multipleUploadState.autoGenerateDescriptions,
        notificar: multipleUploadState.notifyPerson
    });
    
    console.log('üîß Configuraci√≥n del sistema:', {
        maxArchivos: CONFIG.MAX_MULTIPLE_FILES,
        maxTama√±oIndividual: formatFileSize(CONFIG.MAX_FILE_SIZE),
        maxTama√±oTotal: formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE),
        tiposPermitidos: CONFIG.ALLOWED_FILE_TYPES,
        estrategias: CONFIG.UPLOAD_STRATEGIES
    });
    
    // Validar
    const isValid = multipleUploadState.validateAllFiles();
    console.log(`‚úÖ Validaci√≥n: ${isValid ? 'PAS√ì' : 'FALL√ì'}`);
    
    // Estad√≠sticas
    const stats = multipleUploadState.getStats();
    console.table({
        'Total Archivos': stats.total,
        'Pendientes': stats.pending,
        'Subiendo': stats.uploading,
        'Completados': stats.completed,
        'Fallidos': stats.failed,
        'Tama√±o Total': formatFileSize(stats.totalSize),
        'Tama√±o Subido': formatFileSize(stats.uploadedSize)
    });
    
    // Recomendaciones
    console.log('üí° RECOMENDACIONES:');
    if (multipleUploadState.files.length > 10) {
        console.log('   ‚Ä¢ Considera usar estrategia "Por lotes" para mejor rendimiento');
    }
    
    if (multipleUploadState.totalSize > 20 * 1024 * 1024) {
        console.log('   ‚Ä¢ El tama√±o total es grande, la subida puede tardar varios minutos');
    }
    
    const tieneCategor√≠a = multipleUploadState.commonCategory || 
                          multipleUploadState.files.every(f => f.customCategory);
    if (!tieneCategor√≠a) {
        console.log('   ‚ö†Ô∏è  No hay categor√≠a definida para todos los archivos');
    }
    
    console.groupEnd();
    
    showAlert('Diagn√≥stico de subida m√∫ltiple completado. Revisa la consola.', 'info');
}

function testMultipleUploadWithMockFiles() {
    console.group('üß™ TEST CON ARCHIVOS DE PRUEBA');
    
    // Crear archivos de prueba
    const mockFiles = [];
    const fileNames = [
        'documento_prueba_1.pdf',
        'imagen_prueba_1.jpg',
        'excel_prueba_1.xlsx',
        'word_prueba_1.docx',
        'texto_prueba_1.txt'
    ];
    
    fileNames.forEach((fileName, index) => {
        const blob = new Blob([`Contenido de prueba ${index + 1}`], { type: 'text/plain' });
        const file = new File([blob], fileName, {
            type: fileName.endsWith('.pdf') ? 'application/pdf' :
                  fileName.endsWith('.jpg') ? 'image/jpeg' :
                  fileName.endsWith('.xlsx') ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' :
                  fileName.endsWith('.docx') ? 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' :
                  'text/plain',
            lastModified: Date.now()
        });
        
        mockFiles.push(file);
    });
    
    console.log(`üìÅ ${mockFiles.length} archivos de prueba creados`);
    
    // Cambiar a modo m√∫ltiple si no est√°
    if (window.appState.uploadMode !== 'multiple') {
        switchUploadMode('multiple');
    }
    
    // Agregar archivos de prueba
    handleMultipleFiles(mockFiles);
    
    // Configurar valores de prueba
    DOM.multipleDocumentCategory.value = window.appState.categories?.[0]?.nombre || 'General';
    DOM.multipleDocumentPerson.value = window.appState.persons?.[0]?._id || '';
    DOM.multipleExpirationDays.value = '30';
    DOM.uploadStrategy.value = 'sequential';
    
    // Actualizar estado
    updateCommonSettings();
    
    console.log('‚úÖ Test configurado. Archivos listos para subir.');
    console.groupEnd();
    
    showAlert('Test de subida m√∫ltiple configurado. Revisa los archivos de prueba.', 'info');
}

// =============================================================================
// FUNCIONES DE RENDERIZADO DE TABLA
// =============================================================================
async function loadDocuments() {
    try {
        console.log('üìÑ Cargando documentos...');
        
        const data = await apiCall('/documents');
        
        if (data.success) {
            window.appState.documents = (data.documents || []).map(doc => ({
                ...doc,
                url_cloudinary: doc.url_cloudinary || doc.cloudinary_url
            }));
            
            renderDocumentsTable();
            console.log(`‚úÖ ${window.appState.documents.length} documentos cargados`);
        } else {
            throw new Error(data.message);
        }
        
    } catch (error) {
        console.error('‚ùå Error cargando documentos:', error);
        showAlert('Error al cargar documentos: ' + error.message, 'error');
    }
}

function renderDocumentsTable() {
    if (!DOM.documentosTableBody) return;
    
    DOM.documentosTableBody.innerHTML = '';
    
    let documentsToShow = window.appState.documents;
    
    // Aplicar b√∫squeda si existe
    if (window.appState.currentSearchQuery) {
        const query = window.appState.currentSearchQuery.toLowerCase();
        documentsToShow = documentsToShow.filter(doc => 
            doc.nombre_original.toLowerCase().includes(query) ||
            (doc.descripcion && doc.descripcion.toLowerCase().includes(query)) ||
            doc.categoria.toLowerCase().includes(query)
        );
    }
    
    // Aplicar filtros
    if (window.appState.filters.category) {
        documentsToShow = documentsToShow.filter(doc => doc.categoria === window.appState.filters.category);
    }
    
    if (window.appState.filters.type) {
        documentsToShow = documentsToShow.filter(doc => doc.tipo_archivo.toLowerCase() === window.appState.filters.type.toLowerCase());
    }
    
    if (window.appState.filters.date) {
        const now = new Date();
        let startDate;
        
        switch(window.appState.filters.date) {
            case 'today':
                startDate = new Date(now.setHours(0, 0, 0, 0));
                break;
            case 'week':
                startDate = new Date(now.setDate(now.getDate() - 7));
                break;
            case 'month':
                startDate = new Date(now.setMonth(now.getMonth() - 1));
                break;
        }
        
        documentsToShow = documentsToShow.filter(doc => {
            const docDate = new Date(doc.fecha_subida);
            return docDate >= startDate;
        });
    }
    
    if (window.appState.filters.status) {
        const now = new Date();
        documentsToShow = documentsToShow.filter(doc => {
            if (!doc.fecha_vencimiento) return window.appState.filters.status === 'active';
            
            const fechaVencimiento = new Date(doc.fecha_vencimiento);
            const diferenciaDias = Math.ceil((fechaVencimiento - now) / (1000 * 60 * 60 * 24));
            
            switch(window.appState.filters.status) {
                case 'active':
                    return diferenciaDias > 7;
                case 'expiring':
                    return diferenciaDias <= 7 && diferenciaDias > 0;
                case 'expired':
                    return diferenciaDias <= 0;
                default:
                    return true;
            }
        });
    }
    
    if (documentsToShow.length === 0) {
        DOM.documentosTableBody.innerHTML = `
            <tr>
                <td colspan="8" class="empty-state">
                    <i class="fas fa-file-alt empty-state__icon"></i>
                    <h3 class="empty-state__title">No hay documentos</h3>
                    <p class="empty-state__description">${window.appState.currentSearchQuery || window.appState.filters.category || window.appState.filters.type || window.appState.filters.date || window.appState.filters.status ? 'No hay documentos que coincidan con la b√∫squeda o filtros aplicados' : 'Sube tu primer documento para comenzar'}</p>
                </td>
            </tr>
        `;
        return;
    }
    
    documentsToShow.forEach(doc => {
        const person = doc.persona_id ? doc.persona_id : { nombre: 'No asignado' };
        const fileSize = formatFileSize(doc.tamano_archivo);
        const uploadDate = formatDate(doc.fecha_subida);
        
        // Determinar estado de vencimiento
        let vencimientoClass = '';
        let vencimientoText = '';
        let statusIndicator = '';
        
        if (doc.fecha_vencimiento) {
            const fechaVencimiento = new Date(doc.fecha_vencimiento);
            const hoy = new Date();
            const diferenciaDias = Math.ceil((fechaVencimiento - hoy) / (1000 * 60 * 60 * 24));
            
            if (diferenciaDias <= 0) {
                vencimientoClass = 'badge--danger';
                vencimientoText = 'Vencido';
                statusIndicator = '<span class="status-indicator status-indicator--danger"></span>';
            } else if (diferenciaDias <= 7) {
                vencimientoClass = 'badge--warning';
                vencimientoText = `Vence en ${diferenciaDias} d√≠as`;
                statusIndicator = '<span class="status-indicator status-indicator--warning"></span>';
            } else if (diferenciaDias <= 30) {
                vencimientoClass = 'badge--info';
                vencimientoText = `Vence en ${diferenciaDias} d√≠as`;
                statusIndicator = '<span class="status-indicator status-indicator--success"></span>';
            } else {
                vencimientoText = formatDate(doc.fecha_vencimiento);
                statusIndicator = '<span class="status-indicator status-indicator--success"></span>';
            }
        }
        
        const row = document.createElement('tr');
        row.className = 'table__row';
        
        row.innerHTML = `
            <td class="table__cell">
                <div class="documents__info documents__info--inline">
                    <div class="documents__icon documents__icon--sm">
                        <i class="fas fa-file-${getFileIcon(doc.tipo_archivo)}"></i>
                    </div>
                    <div>
                        <div class="documents__details-name">${doc.nombre_original}</div>
                        ${doc.descripcion ? `<div class="documents__details-description">${doc.descripcion}</div>` : ''}
                    </div>
                </div>
            </td>
            <td class="table__cell"><span class="badge badge--info">${doc.tipo_archivo.toUpperCase()}</span></td>
            <td class="table__cell">${fileSize}</td>
            <td class="table__cell">${person.nombre}</td>
            <td class="table__cell"><span class="badge badge--info">${doc.categoria}</span></td>
            <td class="table__cell">${uploadDate}</td>
            <td class="table__cell">
                ${statusIndicator}
                ${vencimientoText ? `<span class="badge ${vencimientoClass}">${vencimientoText}</span>` : 'Sin vencimiento'}
            </td>
            <td class="table__cell">
                <button class="btn btn--sm btn--outline" onclick="window.downloadDocument('${doc._id}')" title="Descargar">
                    <i class="fas fa-download"></i>
                </button>
                <button class="btn btn--sm btn--outline" onclick="window.previewDocument('${doc._id}')" title="Vista previa">
                    <i class="fas fa-eye"></i>
                </button>
                <button class="btn btn--sm btn--danger" onclick="window.deleteDocument('${doc._id}')" title="Eliminar">
                    <i class="fas fa-trash"></i>
                </button>
            </td>
        `;
        
        DOM.documentosTableBody.appendChild(row);
    });
}

// =============================================================================
// EXPORTACIONES CORREGIDAS
// =============================================================================
export { 
    openDocumentModal, 
    closeDocumentModal, 
    setupFileDragAndDrop, 
    handleFile, 
    handleUploadDocument, 
    loadDocuments, 
    renderDocumentsTable, 
    downloadDocument, 
    previewDocument, 
    deleteDocument, 
    handleFileSelect,
    populateDocumentCategorySelect,
    
    // Nuevas funciones para subida m√∫ltiple
    switchUploadMode,
    handleMultipleFiles,
    handleUploadMultipleDocuments,
    handleMultipleFileSelect,
    debugMultipleUpload,
    testMultipleUploadWithMockFiles,
    cancelMultipleUpload,
    
    // Funciones de descarga y diagn√≥stico
    debugDocumentDownload,
    downloadDocumentSimple,
    downloadDocumentAlternative,
    testAllDownloads
};