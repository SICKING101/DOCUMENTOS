import { DOM } from '../dom.js';
import { CONFIG } from '../config.js';
import { apiCall } from '../api.js';
import { setLoadingState, showAlert, formatFileSize, getFileIcon, formatDate } from '../utils.js';

// =============================================================================
// SECCI√ìN 1: ESTADO DE SUBIDA M√öLTIPLE
// =============================================================================

/**
 * Clase que gestiona el estado completo de la subida m√∫ltiple de archivos.
 * Controla archivos pendientes, en progreso, completados y fallidos,
 * as√≠ como configuraciones comunes para todos los archivos.
 */
class MultipleUploadState {
    constructor() {
        this.files = [];
        this.currentUploads = [];
        this.completedUploads = [];
        this.failedUploads = [];
        this.isUploading = false;
        this.totalSize = 0;
        this.commonCategory = '';
        this.commonPersonId = '';
        this.expirationDays = null;
        this.uploadStrategy = 'sequential';
        this.autoGenerateDescriptions = true;
        this.notifyPerson = false;
    }

    /**
     * Reinicia completamente el estado de subida m√∫ltiple.
     * √ötil para comenzar una nueva sesi√≥n de subida.
     */
    reset() {
        this.files = [];
        this.currentUploads = [];
        this.completedUploads = [];
        this.failedUploads = [];
        this.isUploading = false;
        this.totalSize = 0;
        this.commonCategory = '';
        this.commonPersonId = '';
        this.expirationDays = null;
    }

    /**
     * Agrega nuevos archivos al estado, validando cada uno individualmente.
     * Evita duplicados y aplica validaciones de tipo y tama√±o.
     * @param {File[]} newFiles - Array de archivos a agregar
     */
    addFiles(newFiles) {
        console.group('üì¶ Agregando archivos m√∫ltiples');
        
        for (const file of newFiles) {
            // Verificar si ya existe
            const existingFile = this.files.find(f => 
                f.name === file.name && f.size === file.size
            );
            
            if (!existingFile) {
                // Validar archivo individual
                if (this.validateSingleFile(file)) {
                    const fileObj = {
                        file: file,
                        id: this.generateFileId(file),
                        status: 'pending',
                        progress: 0,
                        error: null,
                        description: file.name.replace(/\.[^/.]+$/, ""), // Nombre sin extensi√≥n
                        customCategory: '',
                        customPersonId: '',
                        customExpirationDate: null
                    };
                    
                    this.files.push(fileObj);
                    this.totalSize += file.size;
                    
                    console.log(`‚úÖ Archivo agregado: ${file.name} (${formatFileSize(file.size)})`);
                }
            } else {
                console.log(`‚ö†Ô∏è Archivo duplicado ignorado: ${file.name}`);
            }
        }
        
        console.log(`üìä Total archivos: ${this.files.length}, Tama√±o total: ${formatFileSize(this.totalSize)}`);
        console.groupEnd();
    }

    /**
     * Elimina un archivo del estado por su ID.
     * @param {string} fileId - ID √∫nico del archivo a eliminar
     * @returns {boolean} - True si se elimin√≥ correctamente
     */
    removeFile(fileId) {
        const index = this.files.findIndex(f => f.id === fileId);
        if (index !== -1) {
            const removedFile = this.files[index];
            this.totalSize -= removedFile.file.size;
            this.files.splice(index, 1);
            console.log(`üóëÔ∏è Archivo removido: ${removedFile.file.name}`);
            return true;
        }
        return false;
    }

    /**
     * Valida un archivo individual seg√∫n configuraciones del sistema.
     * Verifica tipo de archivo, tama√±o individual y tama√±o total acumulado.
     * @param {File} file - Archivo a validar
     * @returns {boolean} - True si el archivo es v√°lido
     */
    validateSingleFile(file) {
        try {
            console.log(`üîç Validando archivo: ${file.name}`);
            
            // Validar tipo de archivo
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (!CONFIG.ALLOWED_FILE_TYPES.includes(fileExtension)) {
                console.error(`‚ùå Tipo no permitido: ${fileExtension}`);
                showAlert(
                    `"${file.name}" - Tipo no permitido. Formatos aceptados: ${CONFIG.ALLOWED_FILE_TYPES.join(', ').toUpperCase()}`,
                    'error'
                );
                return false;
            }

            // Validar tama√±o individual
            if (file.size > CONFIG.MAX_FILE_SIZE) {
                console.error(`‚ùå Tama√±o excedido: ${formatFileSize(file.size)} > ${formatFileSize(CONFIG.MAX_FILE_SIZE)}`);
                showAlert(
                    `"${file.name}" - Excede el tama√±o m√°ximo por archivo (${formatFileSize(CONFIG.MAX_FILE_SIZE)})`,
                    'error'
                );
                return false;
            }

            // Validar tama√±o total (si ya hay archivos)
            if (this.totalSize + file.size > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
                console.error(`‚ùå Tama√±o total excedido`);
                showAlert(
                    `"${file.name}" - Excede el tama√±o total permitido para m√∫ltiples archivos`,
                    'error'
                );
                return false;
            }

            console.log(`‚úÖ Archivo v√°lido: ${file.name}`);
            return true;

        } catch (error) {
            console.error(`‚ùå Error validando archivo ${file.name}:`, error);
            showAlert(`Error validando "${file.name}": ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Valida todos los archivos en el estado globalmente.
     * Verifica l√≠mites, categor√≠as y otros requisitos del sistema.
     * @returns {boolean} - True si todos los archivos son v√°lidos
     */
    validateAllFiles() {
        console.group('üîç Validando todos los archivos');
        
        const errors = [];
        
        // Verificar l√≠mite de archivos
        if (this.files.length > CONFIG.MAX_MULTIPLE_FILES) {
            errors.push(`M√°ximo ${CONFIG.MAX_MULTIPLE_FILES} archivos permitidos`);
        }

        // Verificar tama√±o total
        if (this.totalSize > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
            errors.push(`Tama√±o total excedido (${formatFileSize(this.totalSize)} > ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)})`);
        }

        // Verificar que haya archivos
        if (this.files.length === 0) {
            errors.push('No hay archivos seleccionados');
        }

        // Verificar categor√≠a si se requiere
        if (this.commonCategory === '' && this.files.some(f => f.customCategory === '')) {
            errors.push('Debe seleccionar una categor√≠a para todos los archivos o individualmente');
        }

        if (errors.length > 0) {
            console.error('‚ùå Errores de validaci√≥n:', errors);
            errors.forEach(error => showAlert(error, 'error'));
            console.groupEnd();
            return false;
        }

        console.log('‚úÖ Todos los archivos son v√°lidos');
        console.groupEnd();
        return true;
    }

    /**
     * Genera un ID √∫nico para un archivo basado en nombre, tama√±o y timestamp.
     * @param {File} file - Archivo para generar ID
     * @returns {string} - ID √∫nico del archivo
     */
    generateFileId(file) {
        return `${file.name}_${file.size}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Obtiene estad√≠sticas actuales del estado de subida.
     * @returns {object} - Objeto con conteos de archivos por estado y tama√±os
     */
    getStats() {
        return {
            total: this.files.length,
            pending: this.files.filter(f => f.status === 'pending').length,
            uploading: this.files.filter(f => f.status === 'uploading').length,
            completed: this.files.filter(f => f.status === 'completed').length,
            failed: this.files.filter(f => f.status === 'failed').length,
            totalSize: this.totalSize,
            uploadedSize: this.files
                .filter(f => f.status === 'completed')
                .reduce((sum, f) => sum + f.file.size, 0)
        };
    }

    /**
     * Muestra en consola el estado actual de la subida m√∫ltiple.
     * √ötil para debugging y seguimiento de progreso.
     */
    logState() {
        console.group('üìä Estado de Subida M√∫ltiple');
        const stats = this.getStats();
        console.table({
            'Total Archivos': stats.total,
            'Pendientes': stats.pending,
            'Subiendo': stats.uploading,
            'Completados': stats.completed,
            'Fallidos': stats.failed,
            'Tama√±o Total': formatFileSize(stats.totalSize),
            'Subido': formatFileSize(stats.uploadedSize)
        });
        console.groupEnd();
    }
}

// Instancia global del estado de subida m√∫ltiple
const multipleUploadState = new MultipleUploadState();

// =============================================================================
// SECCI√ìN 2: FUNCIONES PRINCIPALES DE DOCUMENTOS (CRUD)
// =============================================================================

/**
 * Abre el modal para subir documentos (individual o m√∫ltiple).
 * Configura los selects, resetea formularios y prepara la interfaz.
 */
function openDocumentModal() {
    console.group('üìÑ Abriendo modal de documento');
    
    // Resetear formularios
    DOM.documentForm.reset();
    DOM.fileInfo.style.display = 'none';
    DOM.uploadDocumentBtn.disabled = true;
    DOM.uploadMultipleDocumentsBtn.disabled = true;
    
    // Resetear estado
    window.appState.selectedFile = null;
    multipleUploadState.reset();
    
    // Resetear UI
    DOM.fileUploadContainer.classList.remove('upload__container--dragover');
    DOM.multipleFileUploadContainer.classList.remove('upload__container--dragover');
    
    // Configurar modo √∫nico por defecto
    switchUploadMode('single');
    
    // Poblar selects - CORREGIDO AQU√ç
    populateDocumentCategorySelect();
    populateMultipleCategorySelect();
    
    // Poblar personas en AMBOS selects
    if (typeof window.populatePersonSelect === 'function') {
        // Poblar para modo individual
        window.populatePersonSelect();
        
        // Poblar para modo m√∫ltiple usando el mismo m√©todo
        window.populatePersonSelect(DOM.multipleDocumentPerson);
    } else {
        // Si no existe la funci√≥n global, crear una versi√≥n local
        populatePersonSelect(DOM.documentPerson);
        populatePersonSelect(DOM.multipleDocumentPerson);
    }
    
    // Mostrar modal
    DOM.documentModal.style.display = 'flex';
    
    // Actualizar UI
    updateMultipleUploadUI();
    
    console.log('‚úÖ Modal de documento abierto');
    console.groupEnd();
}

/**
 * Cierra el modal de documentos, con confirmaci√≥n si hay subidas en progreso.
 */
function closeDocumentModal() {
    console.log('‚ùå Cerrando modal de documento');
    DOM.documentModal.style.display = 'none';
    
    // Si est√° subiendo, preguntar
    if (multipleUploadState.isUploading) {
        if (confirm('Hay archivos subiendo. ¬øSeguro que quieres cancelar?')) {
            cancelMultipleUpload();
        } else {
            DOM.documentModal.style.display = 'flex';
            return;
        }
    }
}

/**
 * Cambia entre modo de subida individual y m√∫ltiple.
 * Actualiza la interfaz y el estado global.
 * @param {string} mode - 'single' para individual, 'multiple' para m√∫ltiple
 */
function switchUploadMode(mode) {
    console.log(`üîÑ Cambiando a modo: ${mode}`);
    
    // Actualizar tabs
    DOM.uploadTabs.forEach(tab => {
        if (tab.dataset.mode === mode) {
            tab.classList.add('upload__tab--active');
        } else {
            tab.classList.remove('upload__tab--active');
        }
    });
    
    // Mostrar/ocultar contenedores
    if (mode === 'single') {
        DOM.singleUploadContainer.classList.add('upload__mode--active');
        DOM.multipleUploadContainer.classList.remove('upload__mode--active');
        DOM.uploadDocumentBtn.style.display = 'flex';
        DOM.uploadMultipleDocumentsBtn.style.display = 'none';
    } else {
        DOM.singleUploadContainer.classList.remove('upload__mode--active');
        DOM.multipleUploadContainer.classList.add('upload__mode--active');
        DOM.uploadDocumentBtn.style.display = 'none';
        DOM.uploadMultipleDocumentsBtn.style.display = 'flex';
        
        // Actualizar UI de m√∫ltiple
        updateMultipleUploadUI();
    }
    
    // Actualizar estado
    window.appState.uploadMode = mode;
}

// =============================================================================
// SECCI√ìN 3: FUNCIONES AUXILIARES DE DOCUMENTOS
// =============================================================================

/**
 * Pobla el select de personas desde la API o estado global.
 * Se usa en ambos modos de subida (individual y m√∫ltiple).
 * @param {HTMLSelectElement} selectElement - Elemento select a poblar
 */
async function populatePersonSelect(selectElement) {
    if (!selectElement) return;
    
    try {
        console.log('üë• Cargando personas para select...');
        
        // Limpiar select
        selectElement.innerHTML = '<option value="">Seleccionar persona</option>';
        
        // Cargar personas si no est√°n en el estado
        if (!window.appState.persons || window.appState.persons.length === 0) {
            const response = await fetch(`${CONFIG.API_BASE_URL}/persons`);
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.persons) {
                    window.appState.persons = data.persons;
                }
            }
        }
        
        // Poblar opciones
        if (window.appState.persons && window.appState.persons.length > 0) {
            window.appState.persons.forEach(person => {
                const option = document.createElement('option');
                option.value = person._id;
                option.textContent = person.nombre || person.name || `Persona ${person._id}`;
                selectElement.appendChild(option);
            });
            
            console.log(`‚úÖ ${window.appState.persons.length} personas cargadas en select`);
        } else {
            console.log('‚ÑπÔ∏è No hay personas disponibles');
        }
        
    } catch (error) {
        console.error('‚ùå Error cargando personas:', error);
        showAlert('Error al cargar la lista de personas', 'error');
    }
}

/**
 * Pobla el select de categor√≠as para el modo individual.
 * Usa las categor√≠as del estado global.
 */
function populateDocumentCategorySelect() {
    if (!DOM.documentCategory) return;
    
    DOM.documentCategory.innerHTML = '<option value="">Seleccionar categor√≠a</option>';
    
    if (window.appState && window.appState.categories) {
        window.appState.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.nombre;
            option.textContent = category.nombre;
            DOM.documentCategory.appendChild(option);
        });
    }
}

/**
 * Pobla el select de categor√≠as para el modo m√∫ltiple.
 * Usa las categor√≠as del estado global.
 */
function populateMultipleCategorySelect() {
    if (!DOM.multipleDocumentCategory) return;
    
    DOM.multipleDocumentCategory.innerHTML = '<option value="">Seleccionar categor√≠a</option>';
    
    if (window.appState && window.appState.categories) {
        window.appState.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.nombre;
            option.textContent = category.nombre;
            DOM.multipleDocumentCategory.appendChild(option);
        });
    }
}

/**
 * Pobla un select de categor√≠as espec√≠fico para archivos individuales en modo m√∫ltiple.
 * @param {HTMLSelectElement} selectElement - Elemento select a poblar
 */
function populateFileCategorySelect(selectElement) {
    if (!selectElement) return;
    
    selectElement.innerHTML = '<option value="">Usar categor√≠a com√∫n</option>';
    
    if (window.appState && window.appState.categories) {
        window.appState.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.nombre;
            option.textContent = category.nombre;
            selectElement.appendChild(option);
        });
    }
}

// =============================================================================
// SECCI√ìN 4: DRAG AND DROP MEJORADO
// =============================================================================

/**
 * Configura el drag and drop para ambos modos de subida.
 * Llama a funciones espec√≠ficas para cada contenedor.
 */
function setupFileDragAndDrop() {
    console.log('üîß Configurando drag and drop...');
    
    // Configurar para modo √∫nico
    if (DOM.fileUploadContainer) {
        setupDragAndDropForElement(DOM.fileUploadContainer, false);
    }
    
    // Configurar para modo m√∫ltiple
    if (DOM.multipleFileUploadContainer) {
        setupDragAndDropForElement(DOM.multipleFileUploadContainer, true);
    }
    
    console.log('‚úÖ Drag and drop configurado');
}

/**
 * Configura eventos de drag and drop para un elemento espec√≠fico.
 * Maneja drag over, drag leave y drop.
 * @param {HTMLElement} element - Elemento donde configurar drag and drop
 * @param {boolean} isMultiple - True si es para modo m√∫ltiple
 */
function setupDragAndDropForElement(element, isMultiple) {
    element.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.add('upload__container--dragover');
    });
    
    element.addEventListener('dragleave', function() {
        this.classList.remove('upload__container--dragover');
    });
    
    element.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('upload__container--dragover');
        
        if (e.dataTransfer.files.length) {
            console.log(`üìÅ ${e.dataTransfer.files.length} archivo(s) arrastrado(s)`);
            
            if (isMultiple) {
                handleMultipleFiles(Array.from(e.dataTransfer.files));
            } else {
                if (e.dataTransfer.files.length > 1) {
                    showAlert('Para subir m√∫ltiples archivos, cambia al modo "Subir M√∫ltiple"', 'warning');
                    return;
                }
                handleFile(e.dataTransfer.files[0]);
            }
        }
    });
}

// =============================================================================
// SECCI√ìN 5: MANEJO DE ARCHIVOS INDIVIDUALES
// =============================================================================

/**
 * Maneja la selecci√≥n de un archivo individual.
 * Valida el archivo y lo almacena en el estado global.
 * @param {File} file - Archivo seleccionado
 */
function handleFile(file) {
    if (!file) {
        console.warn('‚ö†Ô∏è No se proporcion√≥ archivo');
        return;
    }
    
    console.group(`üìã Procesando archivo individual: ${file.name}`);
    
    // Validar archivo
    const fileExtension = file.name.split('.').pop().toLowerCase();
    if (!CONFIG.ALLOWED_FILE_TYPES.includes(fileExtension)) {
        showAlert(`Tipo de archivo no permitido. Formatos aceptados: ${CONFIG.ALLOWED_FILE_TYPES.join(', ').toUpperCase()}`, 'error');
        console.groupEnd();
        return;
    }
    
    if (file.size > CONFIG.MAX_FILE_SIZE) {
        showAlert(`El archivo excede el tama√±o m√°ximo permitido (${formatFileSize(CONFIG.MAX_FILE_SIZE)})`, 'error');
        console.groupEnd();
        return;
    }
    
    // Guardar archivo en estado
    window.appState.selectedFile = file;
    
    // Mostrar informaci√≥n
    DOM.fileName.textContent = file.name;
    DOM.fileSize.textContent = formatFileSize(file.size);
    DOM.fileInfo.style.display = 'block';
    DOM.uploadDocumentBtn.disabled = false;
    
    console.log('‚úÖ Archivo individual validado correctamente');
    console.groupEnd();
}

/**
 * Handler para el input de archivo individual.
 * @param {Event} e - Evento del input file
 */
function handleFileSelect(e) {
    console.log('üìÅ Archivo individual seleccionado:', e.target.files[0]?.name);
    handleFile(e.target.files[0]);
}

// =============================================================================
// SECCI√ìN 6: MANEJO DE M√öLTIPLES ARCHIVOS
// =============================================================================

/**
 * Maneja la selecci√≥n de m√∫ltiples archivos.
 * Valida cantidad m√°xima y agrega archivos al estado.
 * @param {File[]} files - Array de archivos seleccionados
 */
function handleMultipleFiles(files) {
    console.group(`üìÅ Procesando ${files.length} archivo(s) m√∫ltiple(s)`);
    
    // Validar cantidad m√°xima
    if (files.length > CONFIG.MAX_MULTIPLE_FILES) {
        showAlert(`M√°ximo ${CONFIG.MAX_MULTIPLE_FILES} archivos permitidos. Seleccionados: ${files.length}`, 'error');
        console.groupEnd();
        return;
    }
    
    // Agregar archivos al estado
    multipleUploadState.addFiles(files);
    
    // Actualizar UI
    updateMultipleUploadUI();
    
    // Habilitar bot√≥n de subida si hay archivos
    if (multipleUploadState.files.length > 0) {
        DOM.uploadMultipleDocumentsBtn.disabled = false;
        DOM.uploadMultipleDocumentsBtn.querySelector('#uploadCount').textContent = multipleUploadState.files.length;
    }
    
    console.log(`‚úÖ ${files.length} archivo(s) procesado(s)`);
    console.groupEnd();
}

/**
 * Handler para el input de m√∫ltiples archivos.
 * @param {Event} e - Evento del input file m√∫ltiple
 */
function handleMultipleFileSelect(e) {
    console.log('üìÅ M√∫ltiples archivos seleccionados:', e.target.files.length);
    handleMultipleFiles(Array.from(e.target.files));
}

/**
 * Actualiza toda la interfaz de subida m√∫ltiple.
 * Incluye contador, lista de archivos, resumen y configuraci√≥n.
 */
function updateMultipleUploadUI() {
    console.log('üîÑ Actualizando UI de subida m√∫ltiple');
    
    // Actualizar contador
    DOM.selectedFilesCount.textContent = multipleUploadState.files.length;
    
    // Actualizar lista de archivos
    renderFilesList();
    
    // Actualizar resumen
    updateFilesSummary();
    
    // Actualizar configuraci√≥n com√∫n
    updateCommonSettings();
}

/**
 * Renderiza la lista de archivos en el contenedor correspondiente.
 * Muestra estado, progreso y acciones para cada archivo.
 */
function renderFilesList() {
    console.log('üìã Renderizando lista de archivos');
    
    if (!DOM.filesListContainer) {
        console.error('‚ùå Contenedor de lista no encontrado');
        return;
    }
    
    // Limpiar lista
    DOM.filesListContainer.innerHTML = '';
    
    if (multipleUploadState.files.length === 0) {
        DOM.filesListContainer.innerHTML = `
            <div class="files__empty">
                <i class="fas fa-file-alt"></i>
                <p>No hay archivos seleccionados</p>
            </div>
        `;
        return;
    }
    
    // Renderizar cada archivo
    multipleUploadState.files.forEach(fileObj => {
        const file = fileObj.file;
        const fileElement = createFileElement(fileObj);
        DOM.filesListContainer.appendChild(fileElement);
    });
}

/**
 * Crea un elemento DOM para un archivo en la lista.
 * Incluye informaci√≥n, estado, progreso y configuraci√≥n individual.
 * @param {object} fileObj - Objeto de archivo del estado
 * @returns {HTMLElement} - Elemento DOM del archivo
 */
function createFileElement(fileObj) {
    const file = fileObj.file;
    const fileExtension = file.name.split('.').pop().toLowerCase();
    const fileIcon = getFileIcon(fileExtension);
    
    const element = document.createElement('div');
    element.className = `file-item file-item--${fileObj.status}`;
    element.dataset.fileId = fileObj.id;
    
    element.innerHTML = `
        <div class="file-item__header">
            <div class="file-item__icon">
                <i class="fas fa-file-${fileIcon}"></i>
            </div>
            <div class="file-item__info">
                <div class="file-item__name" title="${file.name}">${file.name}</div>
                <div class="file-item__details">
                    <span class="file-item__size">${formatFileSize(file.size)}</span>
                    <span class="file-item__type">${fileExtension.toUpperCase()}</span>
                </div>
            </div>
            <div class="file-item__actions">
                <button class="btn btn--sm btn--danger file-item__remove" title="Eliminar">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
        
        <div class="file-item__body">
            <!-- Estado y progreso -->
            <div class="file-item__status">
                <span class="status-badge status-badge--${fileObj.status}">
                    ${getStatusText(fileObj.status)}
                </span>
                ${fileObj.status === 'uploading' ? `
                    <div class="file-item__progress">
                        <div class="progress-bar">
                            <div class="progress-bar__fill" style="width: ${fileObj.progress}%"></div>
                        </div>
                        <span class="progress-text">${fileObj.progress}%</span>
                    </div>
                ` : ''}
            </div>
            
            <!-- Configuraci√≥n personalizada (colapsable) -->
            <div class="file-item__config" style="display: none;">
                <div class="form__group form__group--sm">
                    <label class="form__label">Descripci√≥n</label>
                    <textarea class="form__textarea form__textarea--sm file-item__description" 
                              rows="2" placeholder="Descripci√≥n del archivo">${fileObj.description || ''}</textarea>
                </div>
                
                <div class="form__row">
                    <div class="form__group form__group--sm">
                        <label class="form__label">Categor√≠a</label>
                        <select class="form__select form__select--sm file-item__category">
                            <option value="">Usar categor√≠a com√∫n</option>
                        </select>
                    </div>
                    <div class="form__group form__group--sm">
                        <label class="form__label">Fecha Vencimiento</label>
                        <input type="date" class="form__input form__input--sm file-item__expiration"
                               value="${fileObj.customExpirationDate || ''}">
                    </div>
                </div>
            </div>
        </div>
        
        ${fileObj.error ? `
            <div class="file-item__error">
                <i class="fas fa-exclamation-circle"></i>
                <span>${fileObj.error}</span>
            </div>
        ` : ''}
    `;
    
    // Agregar event listeners
    const removeBtn = element.querySelector('.file-item__remove');
    const configSection = element.querySelector('.file-item__config');
    
    removeBtn.addEventListener('click', () => {
        if (multipleUploadState.removeFile(fileObj.id)) {
            updateMultipleUploadUI();
            DOM.uploadMultipleDocumentsBtn.querySelector('#uploadCount').textContent = multipleUploadState.files.length;
            
            if (multipleUploadState.files.length === 0) {
                DOM.uploadMultipleDocumentsBtn.disabled = true;
            }
        }
    });
    
    // Actualizar campos cuando cambian
    const descriptionField = element.querySelector('.file-item__description');
    const categoryField = element.querySelector('.file-item__category');
    const expirationField = element.querySelector('.file-item__expiration');
    
    descriptionField.addEventListener('change', (e) => {
        fileObj.description = e.target.value;
    });
    
    categoryField.addEventListener('change', (e) => {
        fileObj.customCategory = e.target.value;
    });
    
    expirationField.addEventListener('change', (e) => {
        fileObj.customExpirationDate = e.target.value;
    });
    
    return element;
}

/**
 * Obtiene el texto legible para un estado de archivo.
 * @param {string} status - Estado del archivo
 * @returns {string} - Texto legible del estado
 */
function getStatusText(status) {
    const statusMap = {
        'pending': 'Pendiente',
        'uploading': 'Subiendo',
        'completed': 'Completado',
        'failed': 'Fallido'
    };
    return statusMap[status] || status;
}

/**
 * Actualiza el resumen de archivos con estad√≠sticas actuales.
 */
function updateFilesSummary() {
    console.log('üìä Actualizando resumen de archivos');
    
    if (!DOM.filesSummary) return;
    
    const stats = multipleUploadState.getStats();
    
    // Calcular tiempo estimado (1MB ‚âà 1 segundo en conexi√≥n buena)
    const estimatedTimeSeconds = Math.ceil(stats.totalSize / (1024 * 1024));
    
    DOM.filesSummary.innerHTML = `
        <div class="summary__item">
            <i class="fas fa-file"></i>
            <span>Total archivos: <strong>${stats.total}</strong></span>
        </div>
        <div class="summary__item">
            <i class="fas fa-hdd"></i>
            <span>Tama√±o total: <strong>${formatFileSize(stats.totalSize)}</strong></span>
        </div>
        <div class="summary__item">
            <i class="fas fa-clock"></i>
            <span>Tiempo estimado: <strong>${estimatedTimeSeconds}s</strong></span>
        </div>
    `;
}

/**
 * Actualiza la configuraci√≥n com√∫n desde los controles de la UI.
 */
function updateCommonSettings() {
    console.log('‚öôÔ∏è Actualizando configuraci√≥n com√∫n');
    
    // Actualizar estado con valores de los selects
    multipleUploadState.commonCategory = DOM.multipleDocumentCategory.value;
    multipleUploadState.commonPersonId = DOM.multipleDocumentPerson.value;
    multipleUploadState.expirationDays = DOM.multipleExpirationDays.value ? parseInt(DOM.multipleExpirationDays.value) : null;
    
    // Actualizar estrategia
    multipleUploadState.uploadStrategy = DOM.uploadStrategy.value;
    
    // Actualizar opciones avanzadas
    multipleUploadState.autoGenerateDescriptions = DOM.autoGenerateDescriptions?.checked || true;
    multipleUploadState.notifyPerson = DOM.notifyPerson?.checked || false;
}

// =============================================================================
// SECCI√ìN 7: SUBIDA DE DOCUMENTOS INDIVIDUAL
// =============================================================================

/**
 * Maneja la subida de un documento individual.
 * Valida, prepara FormData y env√≠a al servidor.
 */
async function handleUploadDocument() {
    console.group('üì§ Subiendo documento individual');
    
    if (!window.appState.selectedFile) {
        showAlert('Por favor selecciona un archivo', 'error');
        console.groupEnd();
        return;
    }
    
    if (!DOM.documentCategory.value) {
        showAlert('Por favor selecciona una categor√≠a', 'error');
        console.groupEnd();
        return;
    }
    
    try {
        setLoadingState(true, DOM.uploadDocumentBtn);
        
        console.log('üìã Iniciando upload del documento...');
        console.log('üìã Archivo:', window.appState.selectedFile.name);
        console.log('üìã Tama√±o:', formatFileSize(window.appState.selectedFile.size));
        
        const formData = new FormData();
        formData.append('file', window.appState.selectedFile);
        formData.append('descripcion', DOM.documentDescription.value);
        formData.append('categoria', DOM.documentCategory.value);
        formData.append('fecha_vencimiento', DOM.documentExpiration.value);
        formData.append('persona_id', DOM.documentPerson.value);

        console.log('üì§ Enviando al servidor...');

        const response = await fetch(`${CONFIG.API_BASE_URL}/documents`, {
            method: 'POST',
            body: formData
        });

        console.log('üì• Respuesta:', response.status);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Error del servidor:', errorText);
            throw new Error(`Error del servidor (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        console.log('üì¶ Datos de respuesta:', data);

        if (data.success) {
            showAlert(data.message, 'success');
            await loadDocuments();
            closeDocumentModal();
            
            if (window.appState.currentTab === 'dashboard') {
                await window.loadDashboardData();
            }
        } else {
            throw new Error(data.message || 'Error desconocido');
        }
        
    } catch (error) {
        console.error('‚ùå Error subiendo documento:', error);
        showAlert('Error al subir documento: ' + error.message, 'error');
    } finally {
        setLoadingState(false, DOM.uploadDocumentBtn);
        console.groupEnd();
    }
}

// =============================================================================
// SECCI√ìN 8: SUBIDA M√öLTIPLE DE DOCUMENTOS
// =============================================================================

/**
 * Maneja la subida m√∫ltiple de documentos.
 * Coordina la subida seg√∫n la estrategia seleccionada y muestra progreso.
 */
async function handleUploadMultipleDocuments() {
    console.group('üì§üì§üì§ SUBIDA M√öLTIPLE DE DOCUMENTOS');
    
    try {
        // Validar antes de empezar
        updateCommonSettings();
        
        if (!multipleUploadState.validateAllFiles()) {
            console.error('‚ùå Validaci√≥n fallida');
            console.groupEnd();
            return;
        }
        
        console.log('üöÄ Iniciando subida m√∫ltiple...');
        multipleUploadState.logState();
        
        // Configurar estado
        multipleUploadState.isUploading = true;
        DOM.uploadMultipleDocumentsBtn.disabled = true;
        DOM.uploadMultipleDocumentsBtn.innerHTML = '<div class="spinner spinner--sm"></div> Preparando...';
        
        // Mostrar contenedor de progreso
        showUploadProgressContainer();
        
        // Iniciar subida seg√∫n estrategia
        const strategy = DOM.uploadStrategy.value;
        console.log(`üîÑ Usando estrategia: ${strategy}`);
        
        let result;
        switch(strategy) {
            case 'sequential':
                result = await uploadSequentially();
                break;
            case 'parallel':
                result = await uploadInParallel();
                break;
            case 'batch':
                result = await uploadInBatches();
                break;
            default:
                result = await uploadSequentially();
        }
        
        // Mostrar resultados
        showUploadResults(result);
        
        // Recargar documentos si hubo √©xito
        if (result.successCount > 0) {
            await loadDocuments();
            
            if (window.appState.currentTab === 'dashboard') {
                await window.loadDashboardData();
            }
        }
        
        console.log('‚úÖ Subida m√∫ltiple completada');
        console.groupEnd();
        
    } catch (error) {
        console.error('‚ùå Error en subida m√∫ltiple:', error);
        showAlert('Error en subida m√∫ltiple: ' + error.message, 'error');
    } finally {
        // Resetear estado
        multipleUploadState.isUploading = false;
        DOM.uploadMultipleDocumentsBtn.disabled = false;
        DOM.uploadMultipleDocumentsBtn.innerHTML = `
            <i class="fas fa-layer-group"></i> 
            Subir Todos (<span id="uploadCount">${multipleUploadState.files.length}</span>)
        `;
        
        // Ocultar progreso despu√©s de un tiempo
        setTimeout(() => {
            hideUploadProgressContainer();
        }, 5000);
    }
}

/**
 * Sube archivos de forma secuencial, uno tras otro.
 * @returns {object} - Resultados de la subida
 */
async function uploadSequentially() {
    console.log('üîÄ Subida secuencial iniciada');
    
    const results = {
        successCount: 0,
        failureCount: 0,
        totalTime: 0,
        uploadedFiles: []
    };
    
    const startTime = Date.now();
    
    for (let i = 0; i < multipleUploadState.files.length; i++) {
        const fileObj = multipleUploadState.files[i];
        
        try {
            // Actualizar estado
            fileObj.status = 'uploading';
            fileObj.progress = 0;
            updateFileUI(fileObj.id);
            
            console.log(`üì§ Subiendo archivo ${i + 1}/${multipleUploadState.files.length}: ${fileObj.file.name}`);
            
            // Subir archivo
            const success = await uploadSingleFileWithProgress(fileObj);
            
            if (success) {
                results.successCount++;
                fileObj.status = 'completed';
                fileObj.progress = 100;
                results.uploadedFiles.push(fileObj.file.name);
                
                console.log(`‚úÖ Archivo subido: ${fileObj.file.name}`);
                showAlert(`‚úÖ ${fileObj.file.name} - Subido correctamente`, 'success');
            } else {
                results.failureCount++;
                fileObj.status = 'failed';
                fileObj.error = 'Error en la subida';
                
                console.error(`‚ùå Error subiendo: ${fileObj.file.name}`);
                showAlert(`‚ùå ${fileObj.file.name} - Error en la subida`, 'error');
            }
            
            updateFileUI(fileObj.id);
            
            // Peque√±a pausa entre archivos (excepto el √∫ltimo)
            if (i < multipleUploadState.files.length - 1) {
                await new Promise(resolve => setTimeout(resolve, CONFIG.UPLOAD_STRATEGIES.SEQUENTIAL.delayBetween));
            }
            
        } catch (error) {
            console.error(`‚ùå Error cr√≠tico en archivo ${fileObj.file.name}:`, error);
            results.failureCount++;
            fileObj.status = 'failed';
            fileObj.error = error.message;
            updateFileUI(fileObj.id);
        }
    }
    
    results.totalTime = Date.now() - startTime;
    console.log(`‚è±Ô∏è  Tiempo total secuencial: ${results.totalTime}ms`);
    
    return results;
}

/**
 * Sube archivos en paralelo con l√≠mite de concurrencia.
 * @returns {object} - Resultados de la subida
 */
async function uploadInParallel() {
    console.log('‚ö° Subida paralela iniciada');
    
    const maxConcurrent = CONFIG.UPLOAD_STRATEGIES.PARALLEL.maxConcurrent;
    const results = {
        successCount: 0,
        failureCount: 0,
        totalTime: 0,
        uploadedFiles: []
    };
    
    const startTime = Date.now();
    
    // Crear array de promesas
    const uploadPromises = [];
    const activeUploads = new Set();
    
    for (let i = 0; i < multipleUploadState.files.length; i++) {
        const fileObj = multipleUploadState.files[i];
        
        // Esperar si hay demasiadas subidas concurrentes
        while (activeUploads.size >= maxConcurrent) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Iniciar subida
        fileObj.status = 'uploading';
        fileObj.progress = 0;
        updateFileUI(fileObj.id);
        
        activeUploads.add(fileObj.id);
        
        const uploadPromise = uploadSingleFileWithProgress(fileObj)
            .then(success => {
                if (success) {
                    results.successCount++;
                    fileObj.status = 'completed';
                    fileObj.progress = 100;
                    results.uploadedFiles.push(fileObj.file.name);
                    console.log(`‚úÖ ${fileObj.file.name} - Completado`);
                } else {
                    results.failureCount++;
                    fileObj.status = 'failed';
                    fileObj.error = 'Error en la subida';
                    console.error(`‚ùå ${fileObj.file.name} - Fallado`);
                }
                
                updateFileUI(fileObj.id);
                activeUploads.delete(fileObj.id);
                
                return success;
            })
            .catch(error => {
                console.error(`‚ùå Error en ${fileObj.file.name}:`, error);
                results.failureCount++;
                fileObj.status = 'failed';
                fileObj.error = error.message;
                updateFileUI(fileObj.id);
                activeUploads.delete(fileObj.id);
                return false;
            });
        
        uploadPromises.push(uploadPromise);
    }
    
    // Esperar a que todas las subidas terminen
    await Promise.all(uploadPromises);
    
    results.totalTime = Date.now() - startTime;
    console.log(`‚è±Ô∏è  Tiempo total paralelo: ${results.totalTime}ms`);
    
    return results;
}

/**
 * Sube archivos por lotes, con pausas entre lotes.
 * @returns {object} - Resultados de la subida
 */
async function uploadInBatches() {
    console.log('üì¶ Subida por lotes iniciada');
    
    const batchSize = CONFIG.MULTIPLE_UPLOAD.BATCH_SIZE;
    const delayBetween = CONFIG.UPLOAD_STRATEGIES.BATCH.delayBetween;
    const results = {
        successCount: 0,
        failureCount: 0,
        totalTime: 0,
        uploadedFiles: []
    };
    
    const startTime = Date.now();
    
    // Dividir archivos en lotes
    const batches = [];
    for (let i = 0; i < multipleUploadState.files.length; i += batchSize) {
        batches.push(multipleUploadState.files.slice(i, i + batchSize));
    }
    
    console.log(`üìä ${batches.length} lotes creados (tama√±o: ${batchSize})`);
    
    // Procesar cada lote
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batch = batches[batchIndex];
        console.log(`üì§ Procesando lote ${batchIndex + 1}/${batches.length}`);
        
        // Subir archivos del lote en paralelo
        const batchPromises = batch.map(fileObj => {
            fileObj.status = 'uploading';
            fileObj.progress = 0;
            updateFileUI(fileObj.id);
            
            return uploadSingleFileWithProgress(fileObj)
                .then(success => {
                    if (success) {
                        results.successCount++;
                        fileObj.status = 'completed';
                        fileObj.progress = 100;
                        results.uploadedFiles.push(fileObj.file.name);
                        console.log(`‚úÖ ${fileObj.file.name} - Completado`);
                    } else {
                        results.failureCount++;
                        fileObj.status = 'failed';
                        fileObj.error = 'Error en la subida';
                        console.error(`‚ùå ${fileObj.file.name} - Fallado`);
                    }
                    
                    updateFileUI(fileObj.id);
                    return success;
                })
                .catch(error => {
                    console.error(`‚ùå Error en ${fileObj.file.name}:`, error);
                    results.failureCount++;
                    fileObj.status = 'failed';
                    fileObj.error = error.message;
                    updateFileUI(fileObj.id);
                    return false;
                });
        });
        
        // Esperar a que termine el lote
        await Promise.all(batchPromises);
        
        // Pausa entre lotes (excepto el √∫ltimo)
        if (batchIndex < batches.length - 1) {
            console.log(`‚è∏Ô∏è  Pausa entre lotes: ${delayBetween}ms`);
            await new Promise(resolve => setTimeout(resolve, delayBetween));
        }
    }
    
    results.totalTime = Date.now() - startTime;
    console.log(`‚è±Ô∏è  Tiempo total por lotes: ${results.totalTime}ms`);
    
    return results;
}

/**
 * Sube un archivo individual con seguimiento de progreso.
 * Usa XMLHttpRequest para obtener eventos de progreso.
 * @param {object} fileObj - Objeto de archivo a subir
 * @returns {Promise<boolean>} - True si la subida fue exitosa
 */
async function uploadSingleFileWithProgress(fileObj) {
    return new Promise(async (resolve, reject) => {
        try {
            console.log(`üì§ Preparando subida: ${fileObj.file.name}`);
            
            // Preparar FormData
            const formData = new FormData();
            formData.append('file', fileObj.file);
            
            // Determinar descripci√≥n
            let description = fileObj.description;
            if (!description && multipleUploadState.autoGenerateDescriptions) {
                description = fileObj.file.name.replace(/\.[^/.]+$/, "");
            }
            formData.append('descripcion', description || '');
            
            // Determinar categor√≠a
            const categoria = fileObj.customCategory || multipleUploadState.commonCategory;
            if (!categoria) {
                throw new Error('Categor√≠a no definida');
            }
            formData.append('categoria', categoria);
            
            // Determinar persona
            const persona_id = fileObj.customPersonId || multipleUploadState.commonPersonId;
            if (persona_id) {
                formData.append('persona_id', persona_id);
            }
            
            // Determinar fecha de vencimiento
            let fecha_vencimiento = fileObj.customExpirationDate;
            if (!fecha_vencimiento && multipleUploadState.expirationDays) {
                const expirationDate = new Date();
                expirationDate.setDate(expirationDate.getDate() + multipleUploadState.expirationDays);
                fecha_vencimiento = expirationDate.toISOString().split('T')[0];
            }
            if (fecha_vencimiento) {
                formData.append('fecha_vencimiento', fecha_vencimiento);
            }
            
            // Configurar notificaci√≥n
            if (multipleUploadState.notifyPerson && persona_id) {
                formData.append('notificar', 'true');
            }
            
            console.log(`üìã Configuraci√≥n para ${fileObj.file.name}:`, {
                descripcion: description,
                categoria: categoria,
                persona_id: persona_id,
                fecha_vencimiento: fecha_vencimiento
            });
            
            // Crear XMLHttpRequest para tener progreso
            const xhr = new XMLHttpRequest();
            
            // Configurar eventos de progreso
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const percentComplete = Math.round((e.loaded / e.total) * 100);
                    fileObj.progress = percentComplete;
                    updateFileUI(fileObj.id);
                    
                    if (CONFIG.DEBUG.LOG_UPLOAD_PROGRESS) {
                        console.log(`üìà ${fileObj.file.name}: ${percentComplete}%`);
                    }
                }
            });
            
            xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        if (response.success) {
                            console.log(`‚úÖ ${fileObj.file.name} - Subida exitosa`);
                            resolve(true);
                        } else {
                            console.error(`‚ùå ${fileObj.file.name} - Error del servidor:`, response.message);
                            fileObj.error = response.message;
                            resolve(false);
                        }
                    } catch (parseError) {
                        console.error(`‚ùå ${fileObj.file.name} - Error parseando respuesta:`, parseError);
                        fileObj.error = 'Error en la respuesta del servidor';
                        resolve(false);
                    }
                } else {
                    console.error(`‚ùå ${fileObj.file.name} - HTTP ${xhr.status}: ${xhr.statusText}`);
                    fileObj.error = `Error HTTP ${xhr.status}`;
                    resolve(false);
                }
            });
            
            xhr.addEventListener('error', () => {
                console.error(`‚ùå ${fileObj.file.name} - Error de red`);
                fileObj.error = 'Error de conexi√≥n';
                resolve(false);
            });
            
            xhr.addEventListener('abort', () => {
                console.warn(`‚ö†Ô∏è ${fileObj.file.name} - Subida cancelada`);
                fileObj.error = 'Subida cancelada';
                resolve(false);
            });
            
            // Enviar la petici√≥n
            xhr.open('POST', `${CONFIG.API_BASE_URL}/documents`);
            xhr.send(formData);
            
        } catch (error) {
            console.error(`‚ùå Error preparando ${fileObj.file.name}:`, error);
            fileObj.error = error.message;
            resolve(false);
        }
    });
}

/**
 * Actualiza la UI de un archivo espec√≠fico en la lista.
 * @param {string} fileId - ID del archivo a actualizar
 */
function updateFileUI(fileId) {
    const fileElement = document.querySelector(`.file-item[data-file-id="${fileId}"]`);
    if (!fileElement) return;
    
    const fileObj = multipleUploadState.files.find(f => f.id === fileId);
    if (!fileObj) return;
    
    // Actualizar clase de estado
    fileElement.className = `file-item file-item--${fileObj.status}`;
    
    // Actualizar badge de estado
    const statusBadge = fileElement.querySelector('.status-badge');
    if (statusBadge) {
        statusBadge.className = `status-badge status-badge--${fileObj.status}`;
        statusBadge.textContent = getStatusText(fileObj.status);
    }
    
    // Actualizar barra de progreso
    const progressBar = fileElement.querySelector('.progress-bar__fill');
    const progressText = fileElement.querySelector('.progress-text');
    
    if (progressBar && fileObj.status === 'uploading') {
        progressBar.style.width = `${fileObj.progress}%`;
        if (progressText) {
            progressText.textContent = `${fileObj.progress}%`;
        }
    }
    
    // Mostrar/ocultar secci√≥n de error
    const errorSection = fileElement.querySelector('.file-item__error');
    if (errorSection) {
        if (fileObj.error) {
            errorSection.style.display = 'flex';
            errorSection.querySelector('span').textContent = fileObj.error;
        } else {
            errorSection.style.display = 'none';
        }
    }
    
    // Actualizar resumen global
    updateOverallProgress();
}

/**
 * Actualiza el progreso general de la subida m√∫ltiple.
 * Actualiza barra de progreso y estad√≠sticas.
 */
function updateOverallProgress() {
    const stats = multipleUploadState.getStats();
    const progressContainer = document.getElementById('uploadProgressContainer');
    
    if (!progressContainer) return;
    
    const totalFiles = stats.total;
    const completedFiles = stats.completed;
    const progressPercent = totalFiles > 0 ? Math.round((completedFiles / totalFiles) * 100) : 0;
    
    // Actualizar barra de progreso principal
    const overallProgressBar = progressContainer.querySelector('.overall-progress__bar-fill');
    const overallProgressText = progressContainer.querySelector('.overall-progress__text');
    
    if (overallProgressBar) {
        overallProgressBar.style.width = `${progressPercent}%`;
    }
    
    if (overallProgressText) {
        overallProgressText.textContent = `${completedFiles}/${totalFiles} archivos (${progressPercent}%)`;
    }
    
    // Actualizar estad√≠sticas
    const statsElement = progressContainer.querySelector('.upload-stats');
    if (statsElement) {
        statsElement.innerHTML = `
            <div class="stat-item">
                <span class="stat-item__label">Completados:</span>
                <span class="stat-item__value stat-item__value--success">${stats.completed}</span>
            </div>
            <div class="stat-item">
                <span class="stat-item__label">Fallidos:</span>
                <span class="stat-item__value stat-item__value--danger">${stats.failed}</span>
            </div>
            <div class="stat-item">
                <span class="stat-item__label">Subiendo:</span>
                <span class="stat-item__value stat-item__value--info">${stats.uploading}</span>
            </div>
            <div class="stat-item">
                <span class="stat-item__label">Tama√±o:</span>
                <span class="stat-item__value">${formatFileSize(stats.uploadedSize)} / ${formatFileSize(stats.totalSize)}</span>
            </div>
        `;
    }
}

/**
 * Muestra el contenedor de progreso de subida m√∫ltiple.
 * Contiene barra de progreso general, estad√≠sticas y tiempo.
 */
function showUploadProgressContainer() {
    console.log('üìä Mostrando contenedor de progreso');
    
    // Crear contenedor si no existe
    let progressContainer = document.getElementById('uploadProgressContainer');
    if (!progressContainer) {
        progressContainer = document.createElement('div');
        progressContainer.id = 'uploadProgressContainer';
        progressContainer.className = 'upload-progress';
        
        progressContainer.innerHTML = `
            <div class="upload-progress__header">
                <h4><i class="fas fa-layer-group"></i> Subida M√∫ltiple en Progreso</h4>
                <button class="btn btn--sm btn--outline" id="cancelUploadBtn">
                    <i class="fas fa-times"></i> Cancelar
                </button>
            </div>
            
            <div class="upload-progress__body">
                <div class="overall-progress">
                    <div class="overall-progress__bar">
                        <div class="overall-progress__bar-fill" style="width: 0%"></div>
                    </div>
                    <div class="overall-progress__text">0/0 archivos (0%)</div>
                </div>
                
                <div class="upload-stats">
                    <!-- Las estad√≠sticas se actualizar√°n din√°micamente -->
                </div>
                
                <div class="current-uploads" id="currentUploadsList">
                    <!-- Las subidas actuales se mostrar√°n aqu√≠ -->
                </div>
            </div>
            
            <div class="upload-progress__footer">
                <div class="upload-speed">
                    <i class="fas fa-tachometer-alt"></i>
                    <span>Velocidad: <span id="uploadSpeed">Calculando...</span></span>
                </div>
                <div class="upload-time">
                    <i class="fas fa-clock"></i>
                    <span>Tiempo: <span id="uploadTime">0s</span></span>
                </div>
            </div>
        `;
        
        // Agregar al body
        document.body.appendChild(progressContainer);
        
        // Agregar event listener para cancelar
        const cancelBtn = document.getElementById('cancelUploadBtn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', cancelMultipleUpload);
        }
    }
    
    // Mostrar contenedor
    progressContainer.style.display = 'block';
    
    // Posicionar
    progressContainer.style.position = 'fixed';
    progressContainer.style.bottom = '20px';
    progressContainer.style.right = '20px';
    progressContainer.style.zIndex = '9999';
    
    // Iniciar actualizaci√≥n de tiempo
    startUploadTimer();
}

/**
 * Oculta el contenedor de progreso de subida m√∫ltiple.
 */
function hideUploadProgressContainer() {
    const progressContainer = document.getElementById('uploadProgressContainer');
    if (progressContainer) {
        progressContainer.style.display = 'none';
    }
}

/**
 * Inicia el temporizador para mostrar tiempo transcurrido de subida.
 */
function startUploadTimer() {
    const startTime = Date.now();
    const timeElement = document.getElementById('uploadTime');
    
    const timer = setInterval(() => {
        if (!multipleUploadState.isUploading) {
            clearInterval(timer);
            return;
        }
        
        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
        if (timeElement) {
            timeElement.textContent = `${elapsedSeconds}s`;
        }
    }, 1000);
}

/**
 * Cancela la subida m√∫ltiple con confirmaci√≥n.
 * Cambia estado de archivos y oculta progreso.
 */
function cancelMultipleUpload() {
    console.log('‚èπÔ∏è Cancelando subida m√∫ltiple...');
    
    if (confirm('¬øEst√°s seguro de que deseas cancelar la subida m√∫ltiple?')) {
        multipleUploadState.isUploading = false;
        
        // Cancelar todas las subidas pendientes
        multipleUploadState.files.forEach(fileObj => {
            if (fileObj.status === 'uploading' || fileObj.status === 'pending') {
                fileObj.status = 'failed';
                fileObj.error = 'Subida cancelada por el usuario';
                updateFileUI(fileObj.id);
            }
        });
        
        showAlert('Subida m√∫ltiple cancelada', 'warning');
        hideUploadProgressContainer();
    }
}

/**
 * Muestra los resultados de la subida m√∫ltiple.
 * Notifica al usuario y limpia archivos exitosos.
 * @param {object} results - Resultados de la subida
 */
function showUploadResults(results) {
    console.group('üìä Resultados de la subida m√∫ltiple');
    console.table({
        'Archivos exitosos': results.successCount,
        'Archivos fallidos': results.failureCount,
        'Tiempo total': `${results.totalTime}ms`,
        'Archivos subidos': results.uploadedFiles.join(', ')
    });
    console.groupEnd();
    
    // Mostrar notificaci√≥n con resultados
    if (results.successCount > 0 && results.failureCount === 0) {
        showAlert(`‚úÖ Todos los ${results.successCount} archivos se subieron correctamente`, 'success');
    } else if (results.successCount > 0) {
        showAlert(
            `‚ö†Ô∏è ${results.successCount} archivos subidos, ${results.failureCount} fallidos. ` +
            `Revisa la lista para m√°s detalles.`,
            'warning'
        );
    } else {
        showAlert(
            `‚ùå Todos los ${results.failureCount} archivos fallaron. ` +
            `Revisa la lista para m√°s detalles.`,
            'error'
        );
    }
    
    // Si todos fallaron, mantener los archivos en la lista
    if (results.successCount > 0) {
        // Remover archivos exitosos
        multipleUploadState.files = multipleUploadState.files.filter(f => f.status !== 'completed');
        updateMultipleUploadUI();
        
        if (multipleUploadState.files.length === 0) {
            // Cerrar modal si no quedan archivos
            setTimeout(() => {
                closeDocumentModal();
            }, 2000);
        }
    }
}

// =============================================================================
// SECCI√ìN 9: FUNCIONES DE DESCARGA DE DOCUMENTOS
// =============================================================================

/**
 * Descarga un documento con manejo robusto de errores.
 * Usa enlace temporal para la descarga.
 * @param {string} id - ID del documento a descargar
 * @returns {Promise<boolean>} - True si la descarga fue exitosa
 */
async function downloadDocument(id) {
    console.group('üöÄ DESCARGAR DOCUMENTO');
    
    try {
        // Verificar que estamos en un navegador
        if (typeof window === 'undefined' || typeof document === 'undefined') {
            throw new Error('Este m√©todo solo funciona en el navegador');
        }
        
        // Buscar documento
        const doc = window.appState.documents.find(d => d._id === id);
        if (!doc) {
            throw new Error('Documento no encontrado');
        }
        
        const fileName = doc.nombre_original;
        
        console.log('üìÑ Descargando:', {
            id: id,
            nombre: fileName,
            tipo: doc.tipo_archivo
        });
        
        showAlert(`Iniciando descarga: ${fileName}`, 'info');
        
        // URL del endpoint
        const endpoint = `${CONFIG.API_BASE_URL}/documents/${id}/download`;
        
        // Agregar par√°metros para evitar cach√©
        const url = new URL(endpoint);
        url.searchParams.append('t', Date.now());
        url.searchParams.append('filename', fileName);
        
        const finalUrl = url.toString();
        console.log('üîó URL final:', finalUrl);
        
        // M√©todo: Enlace temporal (UNICAMENTE ESTE M√âTODO)
        const link = document.createElement('a');
        link.href = finalUrl;
        link.download = fileName;
        
        // Para documentos no-imagen, abrir en nueva pesta√±a
        const fileExtension = fileName.split('.').pop().toLowerCase();
        const isImage = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp'].includes(fileExtension);
        const isPDF = fileExtension === 'pdf';
        const isText = ['txt', 'csv', 'json', 'xml', 'html', 'htm'].includes(fileExtension);
        
        // Solo abrir en nueva pesta√±a para PDFs o texto
        if (isPDF || isText) {
            link.target = '_blank';
        }
        // Para im√°genes, usar descarga directa
        // Para otros tipos (Excel, Word, etc.), tambi√©n descarga directa
        
        link.rel = 'noopener noreferrer';
        link.style.display = 'none';
        
        // Agregar al body
        document.body.appendChild(link);
        
        // Hacer clic UNA VEZ
        link.click();
        
        // Limpiar despu√©s de un tiempo
        setTimeout(() => {
            if (link.parentNode) {
                document.body.removeChild(link);
            }
        }, 3000);
        
        console.log('‚úÖ Descarga iniciada');
        showAlert(`Descarga iniciada: ${fileName}`, 'success');
        
        // NO ABRIR EN NUEVA PESTA√ëA - ESTO CAUSA LA DESCARGA DOBLE
        // Si el usuario quiere abrir en nueva pesta√±a, puede hacerlo manualmente
        
        console.groupEnd();
        return true;
        
    } catch (error) {
        console.error('‚ùå Error en descarga:', error);
        
        // Mostrar error espec√≠fico
        let errorMessage = `Error: ${error.message}`;
        
        if (error.message.includes('document is not defined')) {
            errorMessage = 'Error del navegador. Intenta recargar la p√°gina.';
        } else if (error.message.includes('fetch') || error.message.includes('network')) {
            errorMessage = 'Error de red. Verifica tu conexi√≥n a internet.';
        }
        
        showAlert(errorMessage, 'error');
        console.groupEnd();
        return false;
    }
}

/**
 * Descarga un documento usando m√©todo simple (abrir URL).
 * @param {string} id - ID del documento a descargar
 */
async function downloadDocumentSimple(id) {
    const doc = window.appState.documents.find(d => d._id === id);
    if (!doc) {
        showAlert('Documento no encontrado', 'error');
        return;
    }
    
    console.log('‚ö° Descarga simple para:', doc.nombre_original);
    
    const url = `${CONFIG.API_BASE_URL}/documents/${id}/download?simple=true&t=${Date.now()}`;
    
    // M√©todo ultra simple: abrir URL
    window.open(url, '_blank');
    
    showAlert(`Descargando: ${doc.nombre_original}`, 'info');
}

/**
 * Descarga un documento usando m√©todo alternativo (formulario oculto).
 * √ötil para casos donde el m√©todo principal falla.
 * @param {string} id - ID del documento a descargar
 * @returns {Promise<boolean>} - True si la descarga fue exitosa
 */
async function downloadDocumentAlternative(id) {
    console.group('üîÑ DESCARGAR DOCUMENTO - M√âTODO ALTERNATIVO');
    
    try {
        const doc = window.appState.documents.find(d => d._id === id);
        if (!doc) {
            throw new Error('Documento no encontrado');
        }
        
        const fileName = doc.nombre_original;
        const endpoint = `${CONFIG.API_BASE_URL}/documents/${id}/download`;
        
        console.log('üìÑ Usando m√©todo alternativo para:', fileName);
        showAlert(`Descargando: ${fileName}...`, 'info');
        
        // Crear formulario oculto
        const form = document.createElement('form');
        form.method = 'GET';
        form.action = endpoint;
        form.target = '_blank';
        form.style.display = 'none';
        
        // Agregar par√°metros
        const timestampInput = document.createElement('input');
        timestampInput.type = 'hidden';
        timestampInput.name = 't';
        timestampInput.value = Date.now();
        form.appendChild(timestampInput);
        
        // Agregar al body y enviar
        document.body.appendChild(form);
        form.submit();
        
        // Limpiar
        setTimeout(() => {
            if (form.parentNode) {
                document.body.removeChild(form);
            }
        }, 3000);
        
        console.log('‚úÖ Formulario enviado para descarga');
        console.groupEnd();
        return true;
        
    } catch (error) {
        console.error('‚ùå Error en m√©todo alternativo:', error);
        showAlert(`Error: ${error.message}`, 'error');
        console.groupEnd();
        return false;
    }
}

// =============================================================================
// SECCI√ìN 10: FUNCIONES DE VISTA PREVIA
// =============================================================================

/**
 * Muestra vista previa de un documento seg√∫n su tipo.
 * Usa diferentes estrategias para im√°genes, PDFs, Office y texto.
 * @param {string} id - ID del documento a previsualizar
 */
function previewDocument(id) {
    console.group('üëÅÔ∏è VISTA PREVIA MEJORADA');
    
    try {
        const document = window.appState.documents.find(doc => doc._id === id);
        if (!document) {
            showAlert('Documento no encontrado', 'error');
            console.groupEnd();
            return;
        }
        
        const fileName = document.nombre_original;
        const fileExtension = fileName.split('.').pop().toLowerCase();
        const cloudinaryUrl = document.url_cloudinary || document.cloudinary_url;
        
        console.log('üìã Documento para vista previa:', {
            nombre: fileName,
            extension: fileExtension,
            url: cloudinaryUrl
        });
        
        // Determinar estrategia seg√∫n tipo
        const previewInfo = canPreviewDocument(fileExtension);
        
        if (!previewInfo.canPreview) {
            showAlert('Este tipo de archivo no puede ser previsualizado directamente', 'warning');
            console.groupEnd();
            return;
        }
        
        if (previewInfo.isImage) {
            // Im√°genes: abrir directamente
            console.log('üñºÔ∏è Vista previa de imagen');
            if (cloudinaryUrl) {
                // Crear modal para vista previa de imagen
                showImagePreviewModal(cloudinaryUrl, fileName);
            } else {
                showAlert('No se puede acceder a la imagen', 'error');
            }
            
        } else if (previewInfo.isPDF) {
            // PDF: usar endpoint de preview del servidor
            console.log('üìÑ Vista previa de PDF');
            const previewUrl = `${CONFIG.API_BASE_URL}/documents/${id}/preview`;
            
            // Crear modal para PDF
            showPDFPreviewModal(previewUrl, fileName);
            
        } else if (previewInfo.isOffice && previewInfo.isOnlinePreviewable) {
            // Documentos Office: usar Google Docs Viewer
            console.log('üìù Vista previa de documento Office (Google Docs Viewer)');
            
            if (cloudinaryUrl) {
                const googleDocsViewerUrl = `https://docs.google.com/viewer?url=${encodeURIComponent(cloudinaryUrl)}&embedded=true`;
                showOfficePreviewModal(googleDocsViewerUrl, fileName);
            } else {
                showAlert('No se puede acceder al documento para vista previa', 'error');
            }
            
        } else if (previewInfo.isText) {
            // Texto: cargar y mostrar en modal
            console.log('üìù Vista previa de texto');
            showTextPreviewModal(id, fileName);
            
        } else {
            // Otros tipos previsualizables: intentar abrir en nueva pesta√±a
            console.log('‚ùì Tipo previsualizable, abriendo en nueva pesta√±a');
            if (cloudinaryUrl) {
                window.open(cloudinaryUrl, '_blank');
                showAlert('Abriendo documento en nueva pesta√±a...', 'info');
            } else {
                showAlert('No se puede previsualizar este archivo', 'warning');
            }
        }
        
    } catch (error) {
        console.error('‚ùå Error en vista previa:', error);
        showAlert(`Error: ${error.message}`, 'error');
    } finally {
        console.groupEnd();
    }
}

/**
 * Determina si un tipo de archivo puede ser previsualizado y c√≥mo.
 * @param {string} fileType - Extensi√≥n del archivo
 * @returns {object} - Informaci√≥n sobre capacidad de previsualizaci√≥n
 */
function canPreviewDocument(fileType) {
    // Tipos de archivo que se pueden previsualizar
    const previewableExtensions = [
        'pdf', 'png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 
        'txt', 'csv', 'json', 'xml', 'html', 'htm'
    ];
    
    // Tipos de Office que pueden previsualizarse online (via Google Docs viewer o similar)
    const officePreviewable = ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'];
    
    // Verificar si es una imagen
    const isImage = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp'].includes(fileType.toLowerCase());
    
    // Verificar si es texto plano
    const isText = ['txt', 'csv', 'json', 'xml', 'html', 'htm'].includes(fileType.toLowerCase());
    
    // Verificar si es PDF
    const isPDF = fileType.toLowerCase() === 'pdf';
    
    // Verificar si es Office (puede previsualizarse online)
    const isOffice = officePreviewable.includes(fileType.toLowerCase());
    
    return {
        canPreview: previewableExtensions.includes(fileType.toLowerCase()) || officePreviewable.includes(fileType.toLowerCase()),
        isImage: isImage,
        isText: isText,
        isPDF: isPDF,
        isOffice: isOffice,
        isOnlinePreviewable: officePreviewable.includes(fileType.toLowerCase())
    };
}

/**
 * Muestra modal de vista previa para im√°genes.
 * @param {string} imageUrl - URL de la imagen
 * @param {string} fileName - Nombre del archivo
 */
function showImagePreviewModal(imageUrl, fileName) {
    // Crear modal para imagen
    const modal = document.createElement('div');
    modal.className = 'preview-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    `;
    
    modal.innerHTML = `
        <div class="preview-modal__header" style="
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10000;
        ">
            <h3 style="margin: 0; font-size: 1.1rem;">${fileName}</h3>
            <button class="close-preview" style="
                background: none;
                border: none;
                color: white;
                font-size: 1.5rem;
                cursor: pointer;
            ">&times;</button>
        </div>
        
        <div class="preview-modal__content" style="
            max-width: 90%;
            max-height: 80%;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        ">
            <img src="${imageUrl}" alt="${fileName}" style="
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
            ">
        </div>
        
        <div class="preview-modal__footer" style="
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            text-align: center;
        ">
            <button onclick="window.downloadDocumentFromPreview('${window.appState.documents.find(d => d.nombre_original === fileName)?._id}')" style="
                background: #4f46e5;
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                margin-right: 0.5rem;
            ">
                <i class="fas fa-download"></i> Descargar
            </button>
            <a href="${imageUrl}" target="_blank" style="
                background: #10b981;
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                text-decoration: none;
                display: inline-block;
            ">
                <i class="fas fa-external-link-alt"></i> Abrir en nueva pesta√±a
            </a>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Event listeners
    modal.querySelector('.close-preview').addEventListener('click', () => {
        document.body.removeChild(modal);
    });
    
    // Cerrar con ESC
    document.addEventListener('keydown', function closeOnEsc(e) {
        if (e.key === 'Escape') {
            document.body.removeChild(modal);
            document.removeEventListener('keydown', closeOnEsc);
        }
    });
    
    // Cerrar haciendo clic fuera de la imagen
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });
}

/**
 * Muestra modal de vista previa para PDFs.
 * @param {string} pdfUrl - URL del PDF
 * @param {string} fileName - Nombre del archivo
 */
function showPDFPreviewModal(pdfUrl, fileName) {
    const modal = document.createElement('div');
    modal.className = 'preview-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    `;
    
    modal.innerHTML = `
        <div class="preview-modal__header" style="
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10000;
        ">
            <h3 style="margin: 0; font-size: 1.1rem;">${fileName}</h3>
            <button class="close-preview" style="
                background: none;
                border: none;
                color: white;
                font-size: 1.5rem;
                cursor: pointer;
            ">&times;</button>
        </div>
        
        <div class="preview-modal__content" style="
            width: 90%;
            height: 80%;
            overflow: hidden;
            background: white;
        ">
            <embed src="${pdfUrl}" type="application/pdf" style="
                width: 100%;
                height: 100%;
            ">
        </div>
        
        <div class="preview-modal__footer" style="
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            text-align: center;
        ">
            <button onclick="window.downloadDocumentFromPreview('${window.appState.documents.find(d => d.nombre_original === fileName)?._id}')" style="
                background: #4f46e5;
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                margin-right: 0.5rem;
            ">
                <i class="fas fa-download"></i> Descargar
            </button>
            <a href="${pdfUrl}" target="_blank" style="
                background: #10b981;
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                text-decoration: none;
                display: inline-block;
            ">
                <i class="fas fa-external-link-alt"></i> Abrir en nueva pesta√±a
            </a>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Event listeners
    modal.querySelector('.close-preview').addEventListener('click', () => {
        document.body.removeChild(modal);
    });
    
    // Cerrar con ESC
    document.addEventListener('keydown', function closeOnEsc(e) {
        if (e.key === 'Escape') {
            document.body.removeChild(modal);
            document.removeEventListener('keydown', closeOnEsc);
        }
    });
    
    // Cerrar haciendo clic fuera del contenido
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });
}

/**
 * Muestra modal de vista previa para documentos Office usando Google Docs Viewer.
 * @param {string} viewerUrl - URL de Google Docs Viewer
 * @param {string} fileName - Nombre del archivo
 */
function showOfficePreviewModal(viewerUrl, fileName) {
    const modal = document.createElement('div');
    modal.className = 'preview-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    `;
    
    modal.innerHTML = `
        <div class="preview-modal__header" style="
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10000;
        ">
            <h3 style="margin: 0; font-size: 1.1rem;">${fileName} (Vista previa online)</h3>
            <button class="close-preview" style="
                background: none;
                border: none;
                color: white;
                font-size: 1.5rem;
                cursor: pointer;
            ">&times;</button>
        </div>
        
        <div class="preview-modal__content" style="
            width: 90%;
            height: 80%;
            overflow: hidden;
            background: white;
        ">
            <iframe src="${viewerUrl}" style="
                width: 100%;
                height: 100%;
                border: none;
            "></iframe>
        </div>
        
        <div class="preview-modal__footer" style="
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            text-align: center;
        ">
            <div style="margin-bottom: 0.5rem; font-size: 0.9rem;">
                <i class="fas fa-info-circle"></i> Vista previa proporcionada por Google Docs Viewer
            </div>
            <button onclick="window.downloadDocumentFromPreview('${window.appState.documents.find(d => d.nombre_original === fileName)?._id}')" style="
                background: #4f46e5;
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
            ">
                <i class="fas fa-download"></i> Descargar documento original
            </button>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Event listeners
    modal.querySelector('.close-preview').addEventListener('click', () => {
        document.body.removeChild(modal);
    });
    
    // Cerrar con ESC
    document.addEventListener('keydown', function closeOnEsc(e) {
        if (e.key === 'Escape') {
            document.body.removeChild(modal);
            document.removeEventListener('keydown', closeOnEsc);
        }
    });
    
    // Cerrar haciendo clic fuera del contenido
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });
}

/**
 * Muestra modal de vista previa para archivos de texto.
 * @param {string} documentId - ID del documento
 * @param {string} fileName - Nombre del archivo
 */
async function showTextPreviewModal(documentId, fileName) {
    console.group('üìù VISTA PREVIA DE TEXTO');
    
    try {
        console.log('üìÑ Obteniendo contenido para:', fileName);
        
        // Primero intentar con el endpoint de contenido espec√≠fico
        console.log('üîÑ Intentando endpoint /content...');
        
        try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/documents/${documentId}/content?limit=50000`);
            
            if (response.ok) {
                console.log('‚úÖ Endpoint /content funcion√≥');
                
                // Obtener metadatos de los headers
                const isTruncated = response.headers.get('X-Content-Truncated') === 'true';
                const originalSize = response.headers.get('X-Original-Length');
                const contentType = response.headers.get('Content-Type') || 'text/plain';
                
                const textContent = await response.text();
                console.log(`‚úÖ Contenido obtenido: ${textContent.length} caracteres`);
                
                // Crear modal con metadatos
                createTextPreviewModal(documentId, fileName, textContent, {
                    isTruncated,
                    originalSize: originalSize ? parseInt(originalSize) : null,
                    contentType
                });
                
                console.groupEnd();
                return;
            }
        } catch (contentError) {
            console.warn('‚ö†Ô∏è Endpoint /content fall√≥:', contentError.message);
        }
        
        // Si falla, intentar con el endpoint de descarga
        console.log('üîÑ Intentando endpoint /download como fallback...');
        
        const downloadResponse = await fetch(`${CONFIG.API_BASE_URL}/documents/${documentId}/download`, {
            headers: {
                'Accept': 'text/plain'
            }
        });
        
        if (!downloadResponse.ok) {
            throw new Error(`Error ${downloadResponse.status}: No se pudo obtener el contenido`);
        }
        
        const textContent = await downloadResponse.text();
        console.log(`‚úÖ Contenido obtenido via /download: ${textContent.length} caracteres`);
        
        // Verificar que no sea una p√°gina de error HTML
        if (textContent.includes('<!DOCTYPE html>') || 
            textContent.includes('<html') ||
            textContent.includes('Error al cargar')) {
            console.warn('‚ö†Ô∏è El contenido parece ser HTML de error');
            
            // Intentar obtener directamente desde Cloudinary
            const doc = window.appState.documents.find(d => d._id === documentId);
            if (doc && (doc.cloudinary_url || doc.url_cloudinary)) {
                console.log('üîÑ Intentando desde Cloudinary directamente...');
                
                try {
                    const cloudinaryResponse = await fetch(doc.cloudinary_url || doc.url_cloudinary);
                    if (cloudinaryResponse.ok) {
                        const cloudinaryText = await cloudinaryResponse.text();
                        
                        // Verificar que no sea el mismo error
                        if (!cloudinaryText.includes('<!DOCTYPE html>')) {
                            createTextPreviewModal(documentId, fileName, cloudinaryText);
                            console.groupEnd();
                            return;
                        }
                    }
                } catch (cloudinaryError) {
                    console.warn('‚ö†Ô∏è Cloudinary tambi√©n fall√≥:', cloudinaryError.message);
                }
            }
            
            throw new Error('El servidor devolvi√≥ una p√°gina HTML en lugar del contenido de texto');
        }
        
        // Si todo est√° bien, crear el modal
        createTextPreviewModal(documentId, fileName, textContent);
        
    } catch (error) {
        console.error('‚ùå Error en vista previa de texto:', error);
        
        // Crear modal de error
        createTextPreviewErrorModal(documentId, fileName, error);
    } finally {
        console.groupEnd();
    }
}

/**
 * Crea el modal de vista previa de texto
 */
function createTextPreviewModal(documentId, fileName, textContent, metadata = {}) {
    console.log('üñºÔ∏è Creando modal para:', fileName);
    
    // Renombrar la variable 'document' a 'docData' para evitar conflicto
    // con el objeto global 'document' del navegador
    const docData = window.appState.documents.find(d => d._id === documentId);
    
    // Desestructurar metadata con valores por defecto
    const {
        isTruncated = false,
        originalSize = null,
        contentType = 'text/plain'
    } = metadata;
    
    // Crear elemento modal
    const modal = document.createElement('div');  // Aqu√≠ usamos document GLOBAL del navegador
    modal.className = 'preview-modal preview-modal--text';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.95);
        z-index: 9999;
        display: flex;
        flex-direction: column;
    `;
    
    // Limitar longitud para mostrar (100KB m√°ximo en modal)
    const maxLength = 100000; // 100KB
    let displayContent = textContent;
    let isContentTruncated = false;
    
    if (textContent.length > maxLength) {
        displayContent = textContent.substring(0, maxLength);
        isContentTruncated = true;
    }
    
    // Si metadata indica truncado del servidor
    const finalIsTruncated = isTruncated || isContentTruncated;
    
    // Escapar HTML y manejar saltos de l√≠nea
    displayContent = escapeHtml(displayContent)
        .replace(/\n/g, '<br>')
        .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
        .replace(/  /g, '&nbsp;&nbsp;');
    
    // Preparar estad√≠sticas
    const fileSize = docData ? formatFileSize(docData.tamano_archivo) : 'Desconocido';
    const lines = displayContent.split('<br>').length;
    const words = displayContent.split(/\s+/).filter(w => w.length > 0).length;
    const charCount = textContent.length;
    
    modal.innerHTML = `
        <!-- Header -->
        <div style="
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2d3748;
            flex-shrink: 0;
        ">
            <div>
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <i class="fas fa-file-alt" style="font-size: 1.25rem; color: #4f46e5;"></i>
                    <h3 style="margin: 0; font-size: 1.1rem; font-weight: 600;">${fileName}</h3>
                </div>
                <div style="margin-top: 0.25rem; font-size: 0.85rem; opacity: 0.8; display: flex; gap: 1rem;">
                    <span><i class="fas fa-hdd"></i> ${fileSize}</span>
                    <span><i class="fas fa-font"></i> ${charCount.toLocaleString()} caracteres</span>
                    ${finalIsTruncated ? '<span><i class="fas fa-exclamation-triangle" style="color: #f59e0b;"></i> Truncado</span>' : ''}
                </div>
            </div>
            <button class="close-preview" style="
                background: none;
                border: none;
                color: white;
                font-size: 1.5rem;
                cursor: pointer;
                padding: 0.5rem;
                line-height: 1;
                border-radius: 4px;
                transition: background 0.2s;
            ">&times;</button>
        </div>
        
        <!-- Content -->
        <div style="
            flex: 1;
            overflow: auto;
            padding: 1.5rem;
            background: #0f172a;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #e2e8f0;
        ">
            <!-- Barra de herramientas -->
            <div style="
                background: #1e293b;
                padding: 0.75rem 1rem;
                border-radius: 6px;
                margin-bottom: 1rem;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border: 1px solid #334155;
            ">
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <button class="copy-text-btn" style="
                        background: #374151;
                        color: #d1d5db;
                        border: 1px solid #4b5563;
                        padding: 0.5rem 1rem;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 0.9rem;
                        display: flex;
                        align-items: center;
                        gap: 0.5rem;
                        transition: all 0.2s;
                    " title="Copiar texto completo">
                        <i class="fas fa-copy"></i> Copiar
                    </button>
                    <button class="download-btn" style="
                        background: #1d4ed8;
                        color: white;
                        border: none;
                        padding: 0.5rem 1rem;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 0.9rem;
                        display: flex;
                        align-items: center;
                        gap: 0.5rem;
                        transition: all 0.2s;
                    " title="Descargar archivo completo">
                        <i class="fas fa-download"></i> Descargar
                    </button>
                </div>
                
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <span style="font-size: 0.85rem; color: #9ca3af;">${contentType}</span>
                </div>
            </div>
            
            <!-- Contenido del texto -->
            <div id="textContentDisplay" style="
                background: #0f172a;
                padding: 1.5rem;
                border-radius: 6px;
                border: 1px solid #1e293b;
                white-space: pre-wrap;
                word-wrap: break-word;
                overflow-wrap: break-word;
                min-height: 200px;
            ">
                ${displayContent}
            </div>
            
            <!-- Advertencia de truncado -->
            ${finalIsTruncated ? `
                <div style="
                    margin-top: 1.5rem;
                    padding: 1rem;
                    background: rgba(245, 158, 11, 0.1);
                    border-left: 4px solid #f59e0b;
                    border-radius: 4px;
                    color: #fbbf24;
                ">
                    <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 1.1rem; margin-top: 0.1rem;"></i>
                        <div>
                            <strong style="display: block; margin-bottom: 0.25rem;">Contenido truncado</strong>
                            <p style="margin: 0; font-size: 0.9rem;">
                                ${originalSize ? `Solo se muestran los primeros ${maxLength.toLocaleString()} caracteres 
                                (${((maxLength / originalSize) * 100).toFixed(1)}% del archivo).` : 
                                `Solo se muestran los primeros ${maxLength.toLocaleString()} caracteres.`}
                                Descarga el archivo completo para ver todo el contenido.
                            </p>
                        </div>
                    </div>
                </div>
            ` : ''}
            
            <!-- Informaci√≥n del archivo -->
            <div style="
                margin-top: 1.5rem;
                padding: 1rem;
                background: #1e293b;
                border-radius: 6px;
                font-size: 0.9rem;
                color: #94a3b8;
            ">
                <strong style="display: block; margin-bottom: 0.5rem; color: #cbd5e1;">Informaci√≥n del archivo:</strong>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.75rem;">
                    <div><i class="far fa-file-alt"></i> <strong>Tama√±o:</strong> ${charCount.toLocaleString()} caracteres</div>
                    <div><i class="fas fa-code"></i> <strong>L√≠neas:</strong> ${lines.toLocaleString()}</div>
                    <div><i class="fas fa-font"></i> <strong>Palabras:</strong> ${words.toLocaleString()}</div>
                    <div><i class="fas fa-database"></i> <strong>Bytes:</strong> ${new Blob([textContent]).size.toLocaleString()}</div>
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="
            padding: 1rem 1.5rem;
            background: #1a1a2e;
            border-top: 1px solid #2d3748;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        ">
            <div style="font-size: 0.85rem; color: #9ca3af;">
                <i class="fas fa-info-circle"></i>
                <span>Usa Ctrl+F para buscar en el texto</span>
            </div>
            <div style="display: flex; gap: 0.5rem;">
                <button class="close-btn" style="
                    background: #374151;
                    color: white;
                    border: none;
                    padding: 0.5rem 1.25rem;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 0.9rem;
                ">
                    Cerrar
                </button>
            </div>
        </div>
    `;
    
    // Agregar al DOM
    document.body.appendChild(modal);
    
    // Event listeners
    const closeBtn = modal.querySelector('.close-preview');
    const closeMainBtn = modal.querySelector('.close-btn');
    const copyBtn = modal.querySelector('.copy-text-btn');
    const downloadBtn = modal.querySelector('.download-btn');
    
    // Funci√≥n para cerrar el modal
    const closeModal = () => {
        if (modal.parentNode) {
            document.body.removeChild(modal);
        }
        // Limpiar event listeners globales
        document.removeEventListener('keydown', handleEscKey);
    };
    
    // Funci√≥n para manejar tecla ESC
    const handleEscKey = (e) => {
        if (e.key === 'Escape') {
            closeModal();
        }
    };
    
    // Event listener para cerrar
    closeBtn.addEventListener('click', closeModal);
    closeMainBtn.addEventListener('click', closeModal);
    
    // Event listener para ESC
    document.addEventListener('keydown', handleEscKey);
    
    // Event listener para copiar texto
    copyBtn.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(textContent);
            showAlert('Texto copiado al portapapeles', 'success');
        } catch (err) {
            console.error('Error copiando texto:', err);
            // M√©todo alternativo para navegadores antiguos
            const textArea = document.createElement('textarea');
            textArea.value = textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showAlert('Texto copiado al portapapeles', 'success');
        }
    });
    
    // Event listener para descargar
    downloadBtn.addEventListener('click', () => {
        window.downloadDocument(documentId);
    });
    
    // Buscar con Ctrl+F
    modal.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'f') {
            e.preventDefault();
            showSearchBar();
        }
    });
    
    // Funci√≥n para mostrar barra de b√∫squeda
    function showSearchBar() {
        const existingSearchBar = document.getElementById('textSearchBar');
        if (existingSearchBar) return;
        
        const searchBar = document.createElement('div');
        searchBar.id = 'textSearchBar';
        searchBar.style.cssText = `
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            border: 1px solid #4b5563;
            min-width: 400px;
        `;
        
        searchBar.innerHTML = `
            <input type="text" id="textSearchInput" placeholder="Buscar en el texto..." style="
                flex: 1;
                background: #0f172a;
                border: 1px solid #4b5563;
                color: white;
                padding: 0.5rem 0.75rem;
                border-radius: 4px;
                font-family: inherit;
                font-size: 0.9rem;
            " autofocus>
            <span id="searchResults" style="font-size: 0.85rem; color: #9ca3af; min-width: 80px; text-align: center;">
                0/0
            </span>
            <button class="search-btn" style="
                background: #4f46e5;
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.9rem;
            ">
                <i class="fas fa-search"></i>
            </button>
            <button class="close-search-btn" style="
                background: transparent;
                color: #9ca3af;
                border: none;
                padding: 0.5rem;
                cursor: pointer;
                font-size: 1rem;
            ">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        modal.appendChild(searchBar);
        
        // Funciones de b√∫squeda
        const performSearch = () => {
            const searchTerm = document.getElementById('textSearchInput').value;
            if (!searchTerm.trim()) return;
            
            const textElement = document.getElementById('textContentDisplay');
            const originalContent = textElement.innerHTML;
            const plainText = textElement.textContent || textElement.innerText;
            
            // Encontrar todas las ocurrencias
            const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
            const matches = plainText.match(regex) || [];
            
            // Actualizar contador
            document.getElementById('searchResults').textContent = 
                `${matches.length} resultado(s)`;
            
            // Resaltar
            const highlighted = plainText.replace(
                regex,
                '<mark style="background: #f59e0b; color: #000; padding: 0 2px; border-radius: 2px; font-weight: bold;">$1</mark>'
            );
            
            // Convertir de vuelta a HTML con saltos de l√≠nea
            textElement.innerHTML = highlighted.replace(/\n/g, '<br>');
            
            // Desplazar a la primera coincidencia
            const firstMark = textElement.querySelector('mark');
            if (firstMark) {
                firstMark.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };
        
        const closeSearch = () => {
            searchBar.remove();
            
            // Restaurar contenido original
            const textElement = document.getElementById('textContentDisplay');
            textElement.innerHTML = displayContent;
        };
        
        // Event listeners para b√∫squeda
        searchBar.querySelector('.search-btn').addEventListener('click', performSearch);
        searchBar.querySelector('.close-search-btn').addEventListener('click', closeSearch);
        
        // Buscar al presionar Enter
        searchBar.querySelector('#textSearchInput').addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
        
        // Cerrar b√∫squeda al presionar ESC dentro del input
        searchBar.querySelector('#textSearchInput').addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSearch();
            }
        });
    }
}

/**
 * Crea modal de error para vista previa
 */
function createTextPreviewErrorModal(documentId, fileName, error) {
    const modal = document.createElement('div');
    modal.className = 'preview-modal preview-modal--error';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.95);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    modal.innerHTML = `
        <div style="
            background: #1e293b;
            padding: 2rem;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            color: white;
            border: 1px solid #374151;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        ">
            <div style="text-align: center; margin-bottom: 1.5rem;">
                <div style="
                    width: 60px;
                    height: 60px;
                    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0 auto 1rem;
                ">
                    <i class="fas fa-exclamation-triangle" style="font-size: 1.75rem;"></i>
                </div>
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.25rem; color: #fca5a5;">No se puede previsualizar</h3>
                <p style="margin: 0; opacity: 0.8; font-size: 0.95rem;">${fileName}</p>
            </div>
            
            <div style="
                background: rgba(239, 68, 68, 0.1);
                padding: 1rem;
                border-radius: 8px;
                margin-bottom: 1.5rem;
                border-left: 4px solid #ef4444;
            ">
                <p style="margin: 0; font-size: 0.9rem;">
                    <strong>Error:</strong> ${error.message || 'Error desconocido'}
                </p>
            </div>
            
            <div style="margin-bottom: 1.5rem;">
                <p style="margin: 0 0 0.75rem 0; font-size: 0.95rem; color: #cbd5e1;">
                    <strong>Posibles causas:</strong>
                </p>
                <ul style="margin: 0; padding-left: 1.25rem; font-size: 0.9rem; color: #9ca3af; line-height: 1.5;">
                    <li>El archivo est√° vac√≠o o da√±ado</li>
                    <li>El tipo de archivo no es texto plano v√°lido</li>
                    <li>El servidor no puede acceder al contenido</li>
                    <li>Problemas de permisos o conexi√≥n</li>
                </ul>
            </div>
            
            <div style="display: flex; gap: 0.75rem; justify-content: center; flex-wrap: wrap;">
                <button onclick="window.downloadDocument('${documentId}')" style="
                    background: linear-gradient(135deg, #4f46e5 0%, #3730a3 100%);
                    color: white;
                    border: none;
                    padding: 0.75rem 1.5rem;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    font-size: 0.9rem;
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                    transition: all 0.2s;
                ">
                    <i class="fas fa-download"></i> Descargar archivo
                </button>
                
                <button onclick="closeErrorModal()" style="
                    background: transparent;
                    color: white;
                    border: 1px solid #4b5563;
                    padding: 0.75rem 1.5rem;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 0.9rem;
                    transition: all 0.2s;
                ">
                    Cerrar
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    window.closeErrorModal = function() {
        if (modal.parentNode) {
            document.body.removeChild(modal);
        }
        delete window.closeErrorModal;
    };
    
    // Cerrar con ESC
    document.addEventListener('keydown', function closeOnEsc(e) {
        if (e.key === 'Escape') {
            window.closeErrorModal();
            document.removeEventListener('keydown', closeOnEsc);
        }
    });
    
    // Cerrar al hacer clic fuera
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            window.closeErrorModal();
        }
    });
}

/**
 * Funci√≥n auxiliar para escapar comillas simples en texto
 */
function escapeSingleQuotes(text) {
    return text.replace(/'/g, "\\'");
}

/**
 * Funci√≥n auxiliar para escapar caracteres especiales en expresiones regulares
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Funci√≥n auxiliar para escapar HTML y prevenir XSS.
 * @param {string} text - Texto a escapar
 * @returns {string} - Texto escapado
 */
/**
 * Escapa caracteres HTML para prevenir XSS
 */
function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') return unsafe;
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

// =============================================================================
// SECCI√ìN 11: FUNCIONES DE ELIMINACI√ìN Y CARGA
// =============================================================================

/**
 * Elimina un documento con confirmaci√≥n.
 * @param {string} id - ID del documento a eliminar
 */
async function deleteDocument(id) {
    if (!confirm('¬øEst√°s seguro de que deseas eliminar este documento?')) {
        return;
    }
    
    try {
        console.log('üóëÔ∏è Eliminando documento:', id);
        
        const data = await apiCall(`/documents/${id}`, {
            method: 'DELETE'
        });
        
        if (data.success) {
            showAlert(data.message, 'success');
            await loadDocuments();
            
            if (window.appState.currentTab === 'dashboard') {
                await window.loadDashboardData();
            }
        } else {
            throw new Error(data.message);
        }
        
    } catch (error) {
        console.error('‚ùå Error eliminando documento:', error);
        showAlert('Error al eliminar documento: ' + error.message, 'error');
    }
}

/**
 * Carga documentos desde la API y actualiza el estado global.
 */
async function loadDocuments() {
    try {
        console.log('üìÑ Cargando documentos...');
        
        const data = await apiCall('/documents');
        
        if (data.success) {
            window.appState.documents = (data.documents || []).map(doc => ({
                ...doc,
                url_cloudinary: doc.url_cloudinary || doc.cloudinary_url
            }));
            
            renderDocumentsTable();
            console.log(`‚úÖ ${window.appState.documents.length} documentos cargados`);
        } else {
            throw new Error(data.message);
        }
        
    } catch (error) {
        console.error('‚ùå Error cargando documentos:', error);
        showAlert('Error al cargar documentos: ' + error.message, 'error');
    }
}

// =============================================================================
// SECCI√ìN 12: RENDERIZADO DE TABLA DE DOCUMENTOS
// =============================================================================

/**
 * Renderiza la tabla de documentos con filtros y b√∫squeda aplicados.
 * Muestra estado, acciones y formatos los datos apropiadamente.
 */
function renderDocumentsTable() {
    if (!DOM.documentosTableBody) return;
    
    DOM.documentosTableBody.innerHTML = '';
    
    let documentsToShow = window.appState.documents;
    
    // Aplicar b√∫squeda si existe
    if (window.appState.currentSearchQuery) {
        const query = window.appState.currentSearchQuery.toLowerCase();
        documentsToShow = documentsToShow.filter(doc => 
            doc.nombre_original.toLowerCase().includes(query) ||
            (doc.descripcion && doc.descripcion.toLowerCase().includes(query)) ||
            doc.categoria.toLowerCase().includes(query)
        );
    }
    
    // Aplicar filtros
    if (window.appState.filters.category) {
        documentsToShow = documentsToShow.filter(doc => doc.categoria === window.appState.filters.category);
    }
    
    if (window.appState.filters.type) {
        documentsToShow = documentsToShow.filter(doc => doc.tipo_archivo.toLowerCase() === window.appState.filters.type.toLowerCase());
    }
    
    if (window.appState.filters.date) {
        const now = new Date();
        let startDate;
        
        switch(window.appState.filters.date) {
            case 'today':
                startDate = new Date(now.setHours(0, 0, 0, 0));
                break;
            case 'week':
                startDate = new Date(now.setDate(now.getDate() - 7));
                break;
            case 'month':
                startDate = new Date(now.setMonth(now.getMonth() - 1));
                break;
        }
        
        documentsToShow = documentsToShow.filter(doc => {
            const docDate = new Date(doc.fecha_subida);
            return docDate >= startDate;
        });
    }
    
    if (window.appState.filters.status) {
        const now = new Date();
        documentsToShow = documentsToShow.filter(doc => {
            if (!doc.fecha_vencimiento) return window.appState.filters.status === 'active';
            
            const fechaVencimiento = new Date(doc.fecha_vencimiento);
            const diferenciaDias = Math.ceil((fechaVencimiento - now) / (1000 * 60 * 60 * 24));
            
            switch(window.appState.filters.status) {
                case 'active':
                    return diferenciaDias > 7;
                case 'expiring':
                    return diferenciaDias <= 7 && diferenciaDias > 0;
                case 'expired':
                    return diferenciaDias <= 0;
                default:
                    return true;
            }
        });
    }
    
    if (documentsToShow.length === 0) {
        DOM.documentosTableBody.innerHTML = `
            <tr>
                <td colspan="8" class="empty-state">
                    <i class="fas fa-file-alt empty-state__icon"></i>
                    <h3 class="empty-state__title">No hay documentos</h3>
                    <p class="empty-state__description">${window.appState.currentSearchQuery || window.appState.filters.category || window.appState.filters.type || window.appState.filters.date || window.appState.filters.status ? 'No hay documentos que coincidan con la b√∫squeda o filtros aplicados' : 'Sube tu primer documento para comenzar'}</p>
                </td>
            </tr>
        `;
        return;
    }
    
    documentsToShow.forEach(doc => {
        const person = doc.persona_id ? doc.persona_id : { nombre: 'No asignado' };
        const fileSize = formatFileSize(doc.tamano_archivo);
        const uploadDate = formatDate(doc.fecha_subida);
        
        // Determinar estado de vencimiento
        let vencimientoClass = '';
        let vencimientoText = '';
        let statusIndicator = '';
        
        if (doc.fecha_vencimiento) {
            const fechaVencimiento = new Date(doc.fecha_vencimiento);
            const hoy = new Date();
            const diferenciaDias = Math.ceil((fechaVencimiento - hoy) / (1000 * 60 * 60 * 24));
            
            if (diferenciaDias <= 0) {
                vencimientoClass = 'badge--danger';
                vencimientoText = 'Vencido';
                statusIndicator = '<span class="status-indicator status-indicator--danger"></span>';
            } else if (diferenciaDias <= 7) {
                vencimientoClass = 'badge--warning';
                vencimientoText = `Vence en ${diferenciaDias} d√≠as`;
                statusIndicator = '<span class="status-indicator status-indicator--warning"></span>';
            } else if (diferenciaDias <= 30) {
                vencimientoClass = 'badge--info';
                vencimientoText = `Vence en ${diferenciaDias} d√≠as`;
                statusIndicator = '<span class="status-indicator status-indicator--success"></span>';
            } else {
                vencimientoText = formatDate(doc.fecha_vencimiento);
                statusIndicator = '<span class="status-indicator status-indicator--success"></span>';
            }
        }
        
        // Determinar si se puede previsualizar
        const fileExtension = doc.nombre_original.split('.').pop().toLowerCase();
        const previewInfo = canPreviewDocument(fileExtension);
        
        // Crear botones de acciones
        let actionButtons = `
            <button class="btn btn--sm btn--outline" onclick="window.downloadDocument('${doc._id}')" title="Descargar">
                <i class="fas fa-download"></i>
            </button>
        `;
        
        // Solo agregar bot√≥n de vista previa si se puede previsualizar
        if (previewInfo.canPreview) {
            actionButtons += `
                <button class="btn btn--sm btn--outline" onclick="window.previewDocument('${doc._id}')" title="Vista previa">
                    <i class="fas fa-eye"></i>
                </button>
            `;
        }
        
        // Siempre agregar bot√≥n de eliminar
        actionButtons += `
            <button class="btn btn--sm btn--danger" onclick="window.deleteDocument('${doc._id}')" title="Eliminar">
                <i class="fas fa-trash"></i>
            </button>
        `;
        
        const row = document.createElement('tr');
        row.className = 'table__row';
        
        row.innerHTML = `
            <td class="table__cell">
                <div class="documents__info documents__info--inline">
                    <div class="documents__icon documents__icon--sm">
                        <i class="fas fa-file-${getFileIcon(doc.tipo_archivo)}"></i>
                    </div>
                    <div>
                        <div class="documents__details-name">${doc.nombre_original}</div>
                        ${doc.descripcion ? `<div class="documents__details-description">${doc.descripcion}</div>` : ''}
                    </div>
                </div>
            </td>
            <td class="table__cell"><span class="badge badge--info">${doc.tipo_archivo.toUpperCase()}</span></td>
            <td class="table__cell">${fileSize}</td>
            <td class="table__cell">${person.nombre}</td>
            <td class="table__cell"><span class="badge badge--info">${doc.categoria}</span></td>
            <td class="table__cell">${uploadDate}</td>
            <td class="table__cell">
                ${statusIndicator}
                ${vencimientoText ? `<span class="badge ${vencimientoClass}">${vencimientoText}</span>` : 'Sin vencimiento'}
            </td>
            <td class="table__cell">
                <div class="action-buttons">
                    ${actionButtons}
                </div>
            </td>
        `;
        
        DOM.documentosTableBody.appendChild(row);
    });
}

// =============================================================================
// SECCI√ìN 13: DIAGN√ìSTICO Y DEBUGGING
// =============================================================================

/**
 * Diagn√≥stico de descarga de documentos.
 * Muestra informaci√≥n detallada y probando m√©todos de descarga.
 * @param {string} id - ID del documento a diagnosticar
 */
async function debugDocumentDownload(id) {
    console.group('üêõ DIAGN√ìSTICO DE DESCARGA');
    
    try {
        const doc = window.appState.documents.find(d => d._id === id);
        if (!doc) {
            console.error('‚ùå Documento no encontrado');
            showAlert('Documento no encontrado', 'error');
            console.groupEnd();
            return;
        }
        
        console.log('üìä INFORMACI√ìN DEL DOCUMENTO:');
        console.table({
            'ID': doc._id,
            'Nombre': doc.nombre_original,
            'Tipo': doc.tipo_archivo,
            'Tama√±o': `${doc.tamano_archivo} bytes (${formatFileSize(doc.tamano_archivo)})`,
            'URL Cloudinary': doc.url_cloudinary || doc.cloudinary_url,
            'Fecha subida': formatDate(doc.fecha_subida)
        });
        
        // Probar diferentes m√©todos
        console.log('üß™ PROBANDO M√âTODOS DE DESCARGA:');
        
        // M√©todo 1: Endpoint directo
        const endpoint = `${CONFIG.API_BASE_URL}/documents/${id}/download`;
        console.log('1Ô∏è‚É£ Endpoint:', endpoint);
        
        // M√©todo 2: URL Cloudinary
        if (doc.url_cloudinary || doc.cloudinary_url) {
            console.log('2Ô∏è‚É£ Cloudinary URL:', doc.url_cloudinary || doc.cloudinary_url);
        }
        
        // Recomendaciones
        console.log('üí° RECOMENDACIONES:');
        const extension = doc.nombre_original.split('.').pop().toLowerCase();
        
        if (['png', 'jpg', 'jpeg', 'gif'].includes(extension)) {
            console.log('   ‚Ä¢ Usar endpoint del servidor o URL directa de Cloudinary');
        } else if (extension === 'pdf') {
            console.log('   ‚Ä¢ Usar endpoint del servidor (/download)');
        } else {
            console.log('   ‚Ä¢ Usar endpoint del servidor siempre');
        }
        
        showAlert(`Diagn√≥stico completado para: ${doc.nombre_original}`, 'info');
        
    } catch (error) {
        console.error('‚ùå Error en diagn√≥stico:', error);
        showAlert('Error en diagn√≥stico: ' + error.message, 'error');
    } finally {
        console.groupEnd();
    }
}

/**
 * Prueba todas las descargas disponibles.
 * √ötil para validar que todas las descargas funcionan correctamente.
 */
async function testAllDownloads() {
    console.group('üß™ TEST COMPLETO DE DESCARGAS');
    
    if (!window.appState.documents || window.appState.documents.length === 0) {
        showAlert('No hay documentos para probar', 'warning');
        console.groupEnd();
        return;
    }
    
    const testDocuments = window.appState.documents.slice(0, 2); // Probar solo 2
    const results = [];
    
    showAlert(`Iniciando test de ${testDocuments.length} descargas...`, 'info');
    
    for (const doc of testDocuments) {
        console.log(`\nüîç Probando: ${doc.nombre_original}`);
        
        try {
            const startTime = Date.now();
            await downloadDocument(doc._id);
            const endTime = Date.now();
            
            results.push({
                documento: doc.nombre_original,
                tipo: doc.tipo_archivo,
                tama√±o: formatFileSize(doc.tamano_archivo),
                tiempo: `${endTime - startTime}ms`,
                estado: '‚úÖ EXITOSO'
            });
            
            // Esperar entre descargas
            await new Promise(resolve => setTimeout(resolve, 2000));
            
        } catch (error) {
            results.push({
                documento: doc.nombre_original,
                tipo: doc.tipo_archivo,
                tama√±o: formatFileSize(doc.tamano_archivo),
                tiempo: 'N/A',
                estado: `‚ùå FALLIDO: ${error.message}`
            });
        }
    }
    
    // Mostrar resultados
    console.table(results);
    
    const successful = results.filter(r => r.estado.includes('‚úÖ')).length;
    const total = results.length;
    
    console.log(`\nüìä RESULTADO: ${successful}/${total} descargas exitosas`);
    
    if (successful === total) {
        showAlert('‚úÖ Todas las descargas funcionan correctamente', 'success');
    } else if (successful > 0) {
        showAlert(`‚ö†Ô∏è ${successful}/${total} descargas exitosas`, 'warning');
    } else {
        showAlert('‚ùå Todas las descargas fallaron', 'error');
    }
    
    console.groupEnd();
}

/**
 * Diagn√≥stico de subida m√∫ltiple.
 * Muestra estado, configuraci√≥n y recomendaciones.
 */
function debugMultipleUpload() {
    console.group('üêõ DIAGN√ìSTICO DE SUBIDA M√öLTIPLE');
    
    console.log('üìä Estado actual:', {
        modo: window.appState.uploadMode || 'no definido',
        archivosSeleccionados: multipleUploadState.files.length,
        subiendo: multipleUploadState.isUploading,
        tama√±oTotal: formatFileSize(multipleUploadState.totalSize)
    });
    
    console.log('üìã Archivos individuales:');
    multipleUploadState.files.forEach((fileObj, index) => {
        console.log(`${index + 1}. ${fileObj.file.name}`, {
            tama√±o: formatFileSize(fileObj.file.size),
            estado: fileObj.status,
            progreso: fileObj.progress,
            error: fileObj.error,
            categor√≠aPersonalizada: fileObj.customCategory,
            categor√≠aCom√∫n: multipleUploadState.commonCategory
        });
    });
    
    console.log('‚öôÔ∏è Configuraci√≥n com√∫n:', {
        categor√≠a: multipleUploadState.commonCategory,
        persona: multipleUploadState.commonPersonId,
        d√≠asVencimiento: multipleUploadState.expirationDays,
        estrategia: multipleUploadState.uploadStrategy,
        autoDescripciones: multipleUploadState.autoGenerateDescriptions,
        notificar: multipleUploadState.notifyPerson
    });
    
    console.log('üîß Configuraci√≥n del sistema:', {
        maxArchivos: CONFIG.MAX_MULTIPLE_FILES,
        maxTama√±oIndividual: formatFileSize(CONFIG.MAX_FILE_SIZE),
        maxTama√±oTotal: formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE),
        tiposPermitidos: CONFIG.ALLOWED_FILE_TYPES,
        estrategias: CONFIG.UPLOAD_STRATEGIES
    });
    
    // Validar
    const isValid = multipleUploadState.validateAllFiles();
    console.log(`‚úÖ Validaci√≥n: ${isValid ? 'PAS√ì' : 'FALL√ì'}`);
    
    // Estad√≠sticas
    const stats = multipleUploadState.getStats();
    console.table({
        'Total Archivos': stats.total,
        'Pendientes': stats.pending,
        'Subiendo': stats.uploading,
        'Completados': stats.completed,
        'Fallidos': stats.failed,
        'Tama√±o Total': formatFileSize(stats.totalSize),
        'Tama√±o Subido': formatFileSize(stats.uploadedSize)
    });
    
    // Recomendaciones
    console.log('üí° RECOMENDACIONES:');
    if (multipleUploadState.files.length > 10) {
        console.log('   ‚Ä¢ Considera usar estrategia "Por lotes" para mejor rendimiento');
    }
    
    if (multipleUploadState.totalSize > 20 * 1024 * 1024) {
        console.log('   ‚Ä¢ El tama√±o total es grande, la subida puede tardar varios minutos');
    }
    
    const tieneCategor√≠a = multipleUploadState.commonCategory || 
                          multipleUploadState.files.every(f => f.customCategory);
    if (!tieneCategor√≠a) {
        console.log('   ‚ö†Ô∏è  No hay categor√≠a definida para todos los archivos');
    }
    
    console.groupEnd();
    
    showAlert('Diagn√≥stico de subida m√∫ltiple completado. Revisa la consola.', 'info');
}

/**
 * Prueba la subida m√∫ltiple con archivos mock.
 * √ötil para desarrollo y testing.
 */
function testMultipleUploadWithMockFiles() {
    console.group('üß™ TEST CON ARCHIVOS DE PRUEBA');
    
    // Crear archivos de prueba
    const mockFiles = [];
    const fileNames = [
        'documento_prueba_1.pdf',
        'imagen_prueba_1.jpg',
        'excel_prueba_1.xlsx',
        'word_prueba_1.docx',
        'texto_prueba_1.txt'
    ];
    
    fileNames.forEach((fileName, index) => {
        const blob = new Blob([`Contenido de prueba ${index + 1}`], { type: 'text/plain' });
        const file = new File([blob], fileName, {
            type: fileName.endsWith('.pdf') ? 'application/pdf' :
                  fileName.endsWith('.jpg') ? 'image/jpeg' :
                  fileName.endsWith('.xlsx') ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' :
                  fileName.endsWith('.docx') ? 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' :
                  'text/plain',
            lastModified: Date.now()
        });
        
        mockFiles.push(file);
    });
    
    console.log(`üìÅ ${mockFiles.length} archivos de prueba creados`);
    
    // Cambiar a modo m√∫ltiple si no est√°
    if (window.appState.uploadMode !== 'multiple') {
        switchUploadMode('multiple');
    }
    
    // Agregar archivos de prueba
    handleMultipleFiles(mockFiles);
    
    // Configurar valores de prueba
    DOM.multipleDocumentCategory.value = window.appState.categories?.[0]?.nombre || 'General';
    DOM.multipleDocumentPerson.value = window.appState.persons?.[0]?._id || '';
    DOM.multipleExpirationDays.value = '30';
    DOM.uploadStrategy.value = 'sequential';
    
    // Actualizar estado
    updateCommonSettings();
    
    console.log('‚úÖ Test configurado. Archivos listos para subir.');
    console.groupEnd();
    
    showAlert('Test de subida m√∫ltiple configurado. Revisa los archivos de prueba.', 'info');
}

// =============================================================================
// SECCI√ìN 14: FUNCI√ìN AUXILIAR PARA DESCARGAR DESDE PREVIEW
// =============================================================================

/**
 * Funci√≥n global para descargar documentos desde modales de vista previa.
 * @param {string} documentId - ID del documento a descargar
 */
window.downloadDocumentFromPreview = function(documentId) {
    downloadDocument(documentId);
};

// =============================================================================
// SECCI√ìN 15: EXPORTACIONES
// =============================================================================

export { 
    openDocumentModal, 
    closeDocumentModal, 
    setupFileDragAndDrop, 
    handleFile, 
    handleUploadDocument, 
    loadDocuments, 
    renderDocumentsTable, 
    downloadDocument, 
    previewDocument, 
    deleteDocument, 
    handleFileSelect,
    populateDocumentCategorySelect,
    
    // Nuevas funciones para subida m√∫ltiple
    switchUploadMode,
    handleMultipleFiles,
    handleUploadMultipleDocuments,
    handleMultipleFileSelect,
    debugMultipleUpload,
    testMultipleUploadWithMockFiles,
    cancelMultipleUpload,
    
    // Funciones de descarga y diagn√≥stico
    debugDocumentDownload,
    downloadDocumentSimple,
    downloadDocumentAlternative,
    testAllDownloads,
    
    // Nuevas funciones de vista previa
    canPreviewDocument
};