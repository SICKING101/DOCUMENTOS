// =============================================================================
// src/frontend/modules/documentos/core/MultipleUploadState.js
// =============================================================================

import { CONFIG } from '../../../config.js';
import { formatFileSize, showAlert } from '../../../utils.js';

/**
 * Clase que gestiona el estado completo de la subida mÃºltiple de archivos.
 * Controla archivos pendientes, en progreso, completados y fallidos,
 * asÃ­ como configuraciones comunes para todos los archivos.
 */
export class MultipleUploadState {
    constructor() {
        console.log('ğŸ†• [MultipleUploadState] Constructor - Creando nueva instancia');
        this.reset();
    }

    /**
     * Reinicia completamente el estado de subida mÃºltiple.
     * Ãštil para comenzar una nueva sesiÃ³n de subida.
     */
    reset() {
        console.log('ğŸ”„ [MultipleUploadState] Reset - Reiniciando estado completo');
        this.files = [];
        this.currentUploads = [];
        this.completedUploads = [];
        this.failedUploads = [];
        this.isUploading = false;
        this.totalSize = 0;
        this.commonCategory = '';
        this.commonPersonId = '';
        this.expirationDays = null;
        this.uploadStrategy = 'sequential';
        this.autoGenerateDescriptions = true;
        this.notifyPerson = false;
        this.notifyExpiration = true;
        
        console.log('âœ… [MultipleUploadState] Reset completado:', {
            filesCount: 0,
            commonCategory: '(vacÃ­o)',
            commonPersonId: '(vacÃ­o)',
            expirationDays: null,
            totalSize: '0 bytes'
        });
    }

    /**
     * Agrega nuevos archivos al estado, validando cada uno individualmente.
     * Evita duplicados y aplica validaciones de tipo y tamaÃ±o.
     * @param {File[]} newFiles - Array de archivos a agregar
     * @returns {number} - Cantidad de archivos agregados
     */
    addFiles(newFiles) {
        console.group('ğŸ“¦ [MultipleUploadState] addFiles');
        console.log('ğŸ“ Archivos recibidos para agregar:', newFiles.length);
        
        // Mostrar estado actual antes de agregar
        console.log('ğŸ“Š Estado ACTUAL antes de agregar:', {
            totalArchivos: this.files.length,
            commonCategory: `"${this.commonCategory}"`,
            commonPersonId: `"${this.commonPersonId}"`,
            expirationDays: this.expirationDays,
            totalSize: formatFileSize(this.totalSize)
        });
        
        let addedCount = 0;
        
        for (const file of newFiles) {
            // Verificar si ya existe
            const existingFile = this.files.find(f => 
                f.file.name === file.name && 
                f.file.size === file.size &&
                f.file.lastModified === file.lastModified
            );
            
            if (!existingFile) {
                // Validar archivo individual
                if (this.validateSingleFile(file)) {
                    const fileObj = this.createFileObject(file);
                    this.files.push(fileObj);
                    this.totalSize += file.size;
                    addedCount++;
                    
                    console.log(`âœ… Archivo AGREGADO: ${file.name}`, {
                        size: formatFileSize(file.size),
                        id: fileObj.id,
                        customCategory: fileObj.customCategory || '(vacÃ­a - usarÃ¡ comÃºn)',
                        customPersonId: fileObj.customPersonId || '(vacÃ­a - usarÃ¡ comÃºn)',
                        customExpirationDate: fileObj.customExpirationDate || '(sin fecha - usarÃ¡ comÃºn)',
                        status: fileObj.status
                    });
                }
            } else {
                console.log(`âš ï¸ Archivo DUPLICADO ignorado: ${file.name}`);
            }
        }
        
        // Mostrar estado despuÃ©s de agregar
        console.log(`ğŸ“Š Resumen de operaciÃ³n addFiles:`);
        console.log(`   â€¢ Archivos recibidos: ${newFiles.length}`);
        console.log(`   â€¢ Archivos agregados: ${addedCount}`);
        console.log(`   â€¢ Duplicados ignorados: ${newFiles.length - addedCount}`);
        console.log(`   â€¢ Total archivos ahora: ${this.files.length}`);
        console.log(`   â€¢ TamaÃ±o total ahora: ${formatFileSize(this.totalSize)}`);
        
        // Mostrar detalles de configuraciÃ³n actual
        console.log('ğŸ”§ ConfiguraciÃ³n actual aplicada:');
        console.log(`   â€¢ CategorÃ­a comÃºn: "${this.commonCategory || '(no establecida)'}"`);
        console.log(`   â€¢ Persona comÃºn: "${this.commonPersonId || '(no establecida)'}"`);
        console.log(`   â€¢ DÃ­as de expiraciÃ³n: ${this.expirationDays !== null ? `${this.expirationDays} dÃ­as` : 'no establecido'}`);
        
        // Si hay archivos, mostrar detalles de cada uno
        if (this.files.length > 0) {
            console.log('ğŸ“‹ Detalle de archivos en estado:');
            this.files.forEach((f, i) => {
                const effectiveCategory = this.getEffectiveCategory(f);
                const effectivePersonId = this.getEffectivePersonId(f);
                const effectiveExpirationDate = this.getEffectiveExpirationDate(f);
                
                console.log(`${i + 1}. ${f.file.name}`, {
                    status: f.status,
                    categorÃ­a: effectiveCategory || '(ERROR: sin categorÃ­a)',
                    persona: effectivePersonId || '(sin persona)',
                    vencimiento: effectiveExpirationDate || '(sin fecha)',
                    tamaÃ±o: formatFileSize(f.file.size)
                });
            });
        }
        
        console.groupEnd();
        return addedCount;
    }

    /**
     * Crea un objeto de archivo con todas las propiedades necesarias
     * @param {File} file - Archivo a procesar
     * @returns {object} - Objeto de archivo completo
     */
    createFileObject(file) {
        console.log(`ğŸ“„ [MultipleUploadState] createFileObject para: ${file.name}`);
        
        const fileObj = {
            file: file,
            id: this.generateFileId(file),
            status: 'pending',
            progress: 0,
            error: null,
            description: file.name.replace(/\.[^/.]+$/, ""), // Nombre sin extensiÃ³n
            customCategory: '',
            customPersonId: '',
            customExpirationDate: null,
            addedAt: new Date().toISOString(),
            uploadedAt: null,
            retryCount: 0
        };
        
        console.log(`ğŸ“ Valores por defecto para ${file.name}:`, {
            customCategory: '(vacÃ­o)',
            customPersonId: '(vacÃ­o)',
            customExpirationDate: 'null'
        });
        
        // IMPORTANTE: Asignar valores comunes si existen
        // Esto asegura que los archivos tengan valores desde el principio
        
        // 1. Asignar categorÃ­a comÃºn si existe
        if (this.commonCategory && this.commonCategory.trim() !== '') {
            fileObj.customCategory = this.commonCategory;
            console.log(`ğŸ·ï¸ Asignando categorÃ­a comÃºn "${this.commonCategory}" a: ${file.name}`);
        } else {
            console.log(`ğŸ·ï¸ NO hay categorÃ­a comÃºn para asignar a: ${file.name}`);
        }
        
        // 2. Asignar persona comÃºn si existe
        if (this.commonPersonId && this.commonPersonId.trim() !== '') {
            fileObj.customPersonId = this.commonPersonId;
            console.log(`ğŸ‘¤ Asignando persona comÃºn "${this.commonPersonId}" a: ${file.name}`);
        } else {
            console.log(`ğŸ‘¤ NO hay persona comÃºn para asignar a: ${file.name}`);
        }
        
        // 3. Calcular y asignar fecha de expiraciÃ³n si hay dÃ­as configurados
        if (this.expirationDays !== null && this.expirationDays > 0) {
            fileObj.customExpirationDate = this.calculateExpirationDate(this.expirationDays);
            console.log(`ğŸ“… Asignando fecha de vencimiento ${fileObj.customExpirationDate} a: ${file.name}`);
        } else {
            console.log(`ğŸ“… NO hay dÃ­as de expiraciÃ³n para calcular fecha para: ${file.name}`);
        }
        
        return fileObj;
    }

    /**
     * Calcula una fecha de vencimiento basada en dÃ­as
     * @param {number} days - DÃ­as a agregar
     * @returns {string} - Fecha en formato YYYY-MM-DD
     */
    calculateExpirationDate(days) {
        console.log(`ğŸ“† [MultipleUploadState] calculateExpirationDate: hoy + ${days} dÃ­as`);
        
        const expirationDate = new Date();
        expirationDate.setDate(expirationDate.getDate() + days);
        const formattedDate = expirationDate.toISOString().split('T')[0];
        
        console.log(`ğŸ“† Fecha calculada: ${formattedDate}`);
        return formattedDate;
    }

    /**
     * Elimina un archivo del estado por su ID.
     * @param {string} fileId - ID Ãºnico del archivo a eliminar
     * @returns {boolean} - True si se eliminÃ³ correctamente
     */
    removeFile(fileId) {
        console.log(`ğŸ—‘ï¸ [MultipleUploadState] removeFile - ID: ${fileId}`);
        
        const index = this.files.findIndex(f => f.id === fileId);
        if (index !== -1) {
            const removedFile = this.files[index];
            this.totalSize -= removedFile.file.size;
            this.files.splice(index, 1);
            
            console.log(`âœ… Archivo REMOVIDO: ${removedFile.file.name}`, {
                tamaÃ±oRestado: formatFileSize(removedFile.file.size),
                totalArchivosRestantes: this.files.length,
                tamaÃ±oTotalAhora: formatFileSize(this.totalSize)
            });
            
            return true;
        }
        
        console.log(`âŒ No se encontrÃ³ archivo con ID: ${fileId}`);
        return false;
    }

    /**
     * Actualiza la categorÃ­a comÃºn y la aplica a todos los archivos pendientes
     * @param {string} category - Nueva categorÃ­a comÃºn
     */
    setCommonCategory(category) {
        console.group(`ğŸ·ï¸ [MultipleUploadState] setCommonCategory`);
        console.log(`ğŸ“ Valor recibido: "${category}"`);
        console.log(`ğŸ“ Valor anterior: "${this.commonCategory}"`);
        
        // Guardar nueva categorÃ­a
        const oldCategory = this.commonCategory;
        this.commonCategory = category ? category.trim() : '';
        
        console.log(`âœ… CategorÃ­a comÃºn ACTUALIZADA: "${oldCategory}" â†’ "${this.commonCategory}"`);
        
        // Aplicar a todos los archivos pendientes sin categorÃ­a personalizada
        let updatedCount = 0;
        this.files.forEach(file => {
            if (file.status === 'pending') {
                // Solo actualizar si no hay categorÃ­a personalizada
                if (!file.customCategory || file.customCategory.trim() === '') {
                    file.customCategory = this.commonCategory;
                    updatedCount++;
                    console.log(`ğŸ”„ Aplicada categorÃ­a comÃºn a: ${file.file.name}`);
                } else {
                    console.log(`âš ï¸ ${file.file.name} ya tiene categorÃ­a personalizada: "${file.customCategory}"`);
                }
            }
        });
        
        console.log(`ğŸ“Š Resumen: ${updatedCount} archivo(s) actualizado(s) con categorÃ­a comÃºn`);
        
        // VerificaciÃ³n despuÃ©s de actualizar
        const categoryCheck = this.checkCategories();
        console.log(`ğŸ” VerificaciÃ³n POST-actualizaciÃ³n:`, {
            totalArchivos: categoryCheck.totalFiles,
            conCategorÃ­a: categoryCheck.filesWithCategory,
            sinCategorÃ­a: categoryCheck.missingCategories
        });
        
        console.groupEnd();
    }

    /**
     * Actualiza la persona comÃºn y la aplica a todos los archivos pendientes
     * @param {string} personId - Nueva persona comÃºn
     */
    setCommonPersonId(personId) {
        console.group(`ğŸ‘¤ [MultipleUploadState] setCommonPersonId`);
        console.log(`ğŸ“ Valor recibido: "${personId}"`);
        console.log(`ğŸ“ Valor anterior: "${this.commonPersonId}"`);
        
        // Guardar nueva persona
        const oldPersonId = this.commonPersonId;
        this.commonPersonId = personId ? personId.trim() : '';
        
        console.log(`âœ… Persona comÃºn ACTUALIZADA: "${oldPersonId}" â†’ "${this.commonPersonId}"`);
        
        // Aplicar a todos los archivos pendientes sin persona personalizada
        let updatedCount = 0;
        this.files.forEach(file => {
            if (file.status === 'pending') {
                // Solo actualizar si no hay persona personalizada
                if (!file.customPersonId || file.customPersonId.trim() === '') {
                    file.customPersonId = this.commonPersonId;
                    updatedCount++;
                    console.log(`ğŸ”„ Aplicada persona comÃºn a: ${file.file.name}`);
                } else {
                    console.log(`âš ï¸ ${file.file.name} ya tiene persona personalizada: "${file.customPersonId}"`);
                }
            }
        });
        
        console.log(`ğŸ“Š Resumen: ${updatedCount} archivo(s) actualizado(s) con persona comÃºn`);
        
        // VerificaciÃ³n despuÃ©s de actualizar
        const filesWithPerson = this.files.filter(f => 
            this.getEffectivePersonId(f) && this.getEffectivePersonId(f).trim() !== ''
        ).length;
        console.log(`ğŸ” VerificaciÃ³n POST-actualizaciÃ³n:`, {
            totalArchivos: this.files.length,
            conPersona: filesWithPerson,
            sinPersona: this.files.length - filesWithPerson
        });
        
        console.groupEnd();
    }

    /**
     * Actualiza los dÃ­as de expiraciÃ³n y calcula fechas para todos los archivos pendientes
     * @param {number|string} days - DÃ­as hasta el vencimiento
     */
    setExpirationDays(days) {
        console.group(`ğŸ“… [MultipleUploadState] setExpirationDays`);
        console.log(`ğŸ“ Valor recibido: "${days}" (tipo: ${typeof days})`);
        console.log(`ğŸ“ Valor anterior: ${this.expirationDays}`);
        
        // Validar y convertir el valor
        const daysNumber = parseInt(days);
        
        if (isNaN(daysNumber) || daysNumber <= 0) {
            this.expirationDays = null;
            console.log('âœ… DÃ­as de expiraciÃ³n establecidos como: null (sin vencimiento)');
            
            // Eliminar fechas de vencimiento de todos los archivos pendientes sin fecha personalizada
            let clearedCount = 0;
            this.files.forEach(file => {
                if (file.status === 'pending') {
                    if (!file.customExpirationDate) {
                        file.customExpirationDate = null;
                        clearedCount++;
                    }
                }
            });
            console.log(`ğŸ—‘ï¸ ${clearedCount} archivo(s) con fecha de vencimiento limpiada`);
            
        } else {
            this.expirationDays = daysNumber;
            console.log(`âœ… DÃ­as de expiraciÃ³n establecidos: ${this.expirationDays} dÃ­as`);
            
            // Calcular fecha de vencimiento
            const expirationDate = this.calculateExpirationDate(daysNumber);
            console.log(`ğŸ“… Fecha calculada para vencimiento: ${expirationDate}`);
            
            // Aplicar a todos los archivos pendientes sin fecha personalizada
            let updatedCount = 0;
            this.files.forEach(file => {
                if (file.status === 'pending') {
                    // Solo actualizar si no hay fecha personalizada
                    if (!file.customExpirationDate) {
                        file.customExpirationDate = expirationDate;
                        updatedCount++;
                        console.log(`ğŸ”„ Aplicada fecha de vencimiento a: ${file.file.name}`);
                    } else {
                        console.log(`âš ï¸ ${file.file.name} ya tiene fecha personalizada: "${file.customExpirationDate}"`);
                    }
                }
            });
            
            console.log(`ğŸ“Š Resumen: ${updatedCount} archivo(s) actualizado(s) con fecha de vencimiento`);
        }
        
        // VerificaciÃ³n despuÃ©s de actualizar
        const filesWithDate = this.files.filter(f => 
            this.getEffectiveExpirationDate(f)
        ).length;
        console.log(`ğŸ” VerificaciÃ³n POST-actualizaciÃ³n:`, {
            totalArchivos: this.files.length,
            conFechaVencimiento: filesWithDate,
            sinFechaVencimiento: this.files.length - filesWithDate
        });
        
        console.groupEnd();
    }

    /**
     * VALOR CRÃTICO: Aplica la configuraciÃ³n comÃºn a TODOS los archivos pendientes
     * Esto asegura que todos los archivos tengan los valores correctos antes de subir
     * @returns {number} - NÃºmero de archivos actualizados
     */
    applyCommonSettingsToAllFiles() {
        console.group('ğŸ”„ [MultipleUploadState] applyCommonSettingsToAllFiles');
        
        console.log('ğŸ”§ ConfiguraciÃ³n comÃºn actual:', {
            categorÃ­a: `"${this.commonCategory || '(vacÃ­a)'}"`,
            persona: `"${this.commonPersonId || '(vacÃ­a)'}"`,
            dÃ­asExpiraciÃ³n: this.expirationDays !== null ? `${this.expirationDays} dÃ­as` : 'null'
        });
        
        let updatedFiles = 0;
        let skippedFiles = 0;
        
        this.files.forEach((file, index) => {
            if (file.status === 'pending') {
                let fileUpdated = false;
                
                console.log(`${index + 1}. Procesando: ${file.file.name}`, {
                    categorÃ­aActual: file.customCategory || '(vacÃ­a)',
                    personaActual: file.customPersonId || '(vacÃ­a)',
                    fechaActual: file.customExpirationDate || '(sin fecha)'
                });
                
                // 1. Aplicar categorÃ­a comÃºn si no tiene personalizada
                if (this.commonCategory && this.commonCategory.trim() !== '') {
                    if (!file.customCategory || file.customCategory.trim() === '') {
                        file.customCategory = this.commonCategory;
                        fileUpdated = true;
                        console.log(`   ğŸ·ï¸ CategorÃ­a actualizada: "${this.commonCategory}"`);
                    } else {
                        console.log(`   âš ï¸ Mantiene categorÃ­a personalizada: "${file.customCategory}"`);
                    }
                } else {
                    console.log(`   âŒ No hay categorÃ­a comÃºn para aplicar`);
                }
                
                // 2. Aplicar persona comÃºn si no tiene personalizada
                if (this.commonPersonId && this.commonPersonId.trim() !== '') {
                    if (!file.customPersonId || file.customPersonId.trim() === '') {
                        file.customPersonId = this.commonPersonId;
                        fileUpdated = true;
                        console.log(`   ğŸ‘¤ Persona actualizada: "${this.commonPersonId}"`);
                    } else {
                        console.log(`   âš ï¸ Mantiene persona personalizada: "${file.customPersonId}"`);
                    }
                } else {
                    console.log(`   âŒ No hay persona comÃºn para aplicar`);
                }
                
                // 3. Aplicar fecha de vencimiento si no tiene personalizada y hay dÃ­as configurados
                if (this.expirationDays !== null && this.expirationDays > 0) {
                    if (!file.customExpirationDate) {
                        const expirationDate = this.calculateExpirationDate(this.expirationDays);
                        file.customExpirationDate = expirationDate;
                        fileUpdated = true;
                        console.log(`   ğŸ“… Fecha actualizada: ${expirationDate} (+${this.expirationDays} dÃ­as)`);
                    } else {
                        console.log(`   âš ï¸ Mantiene fecha personalizada: "${file.customExpirationDate}"`);
                    }
                } else {
                    console.log(`   âŒ No hay dÃ­as de expiraciÃ³n para calcular fecha`);
                }
                
                if (fileUpdated) {
                    updatedFiles++;
                    console.log(`   âœ… Archivo ACTUALIZADO con configuraciÃ³n comÃºn`);
                } else {
                    skippedFiles++;
                    console.log(`   ğŸ”„ Archivo MANTENIDO (ya tiene configuraciÃ³n personalizada)`);
                }
                
                // Mostrar valores efectivos despuÃ©s de la aplicaciÃ³n
                console.log(`   ğŸ“Š Valores efectivos despuÃ©s:`, {
                    categorÃ­a: this.getEffectiveCategory(file) || '(vacÃ­a)',
                    persona: this.getEffectivePersonId(file) || '(vacÃ­a)',
                    fecha: this.getEffectiveExpirationDate(file) || '(sin fecha)'
                });
            } else {
                console.log(`${index + 1}. ${file.file.name} - SKIP (estado: ${file.status})`);
            }
        });
        
        console.log('ğŸ“Š RESUMEN:', {
            archivosTotales: this.files.length,
            archivosActualizados: updatedFiles,
            archivosMantenidos: skippedFiles,
            archivosConCategorÃ­a: this.files.filter(f => this.getEffectiveCategory(f)).length,
            archivosConPersona: this.files.filter(f => this.getEffectivePersonId(f)).length,
            archivosConFecha: this.files.filter(f => this.getEffectiveExpirationDate(f)).length
        });
        
        console.groupEnd();
        return updatedFiles;
    }

    /**
     * Valida un archivo individual segÃºn configuraciones del sistema.
     * Verifica tipo de archivo, tamaÃ±o individual y tamaÃ±o total acumulado.
     * @param {File} file - Archivo a validar
     * @returns {boolean} - True si el archivo es vÃ¡lido
     */
    validateSingleFile(file) {
        console.log(`ğŸ” [MultipleUploadState] validateSingleFile: ${file.name}`);
        
        try {
            // Validar tipo de archivo
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (!CONFIG.ALLOWED_FILE_TYPES.includes(fileExtension)) {
                console.error(`âŒ Tipo NO PERMITIDO: ${fileExtension}`);
                console.error(`âŒ Extensiones permitidas: ${CONFIG.ALLOWED_FILE_TYPES.join(', ')}`);
                showAlert(
                    `"${file.name}" - Tipo no permitido. Formatos aceptados: ${CONFIG.ALLOWED_FILE_TYPES.join(', ').toUpperCase()}`,
                    'error'
                );
                return false;
            }

            // Validar tamaÃ±o individual
            if (file.size > CONFIG.MAX_FILE_SIZE) {
                console.error(`âŒ TamaÃ±o EXCEDIDO: ${formatFileSize(file.size)} > ${formatFileSize(CONFIG.MAX_FILE_SIZE)}`);
                showAlert(
                    `"${file.name}" - Excede el tamaÃ±o mÃ¡ximo por archivo (${formatFileSize(CONFIG.MAX_FILE_SIZE)})`,
                    'error'
                );
                return false;
            }

            // Validar tamaÃ±o total (si ya hay archivos)
            if (this.totalSize + file.size > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
                console.error(`âŒ TamaÃ±o TOTAL excedido`);
                console.error(`âŒ Actual: ${formatFileSize(this.totalSize)} + Nuevo: ${formatFileSize(file.size)} > LÃ­mite: ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)}`);
                showAlert(
                    `"${file.name}" - Excede el tamaÃ±o total permitido para mÃºltiples archivos`,
                    'error'
                );
                return false;
            }

            console.log(`âœ… Archivo VÃLIDO: ${file.name}`);
            return true;

        } catch (error) {
            console.error(`âŒ ERROR validando archivo ${file.name}:`, error);
            showAlert(`Error validando "${file.name}": ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Valida todos los archivos en el estado globalmente.
     * Verifica lÃ­mites, categorÃ­as y otros requisitos del sistema.
     * @returns {boolean} - True si todos los archivos son vÃ¡lidos
     */
    validateAllFiles() {
        console.group('ğŸ” [MultipleUploadState] VALIDACIÃ“N COMPLETA');
        
        const errors = [];
        
        // Mostrar estado actual para debugging
        console.log('ğŸ“Š Estado ACTUAL para validaciÃ³n:', {
            totalArchivos: this.files.length,
            commonCategory: `"${this.commonCategory}"`,
            commonPersonId: `"${this.commonPersonId}"`,
            expirationDays: this.expirationDays,
            totalSize: formatFileSize(this.totalSize)
        });
        
        // 1. Verificar que haya archivos
        if (this.files.length === 0) {
            errors.push('No hay archivos seleccionados');
            console.error('âŒ ERROR: No hay archivos para validar');
            console.groupEnd();
            return false;
        }

        // 2. Verificar lÃ­mite de archivos
        if (this.files.length > CONFIG.MAX_MULTIPLE_FILES) {
            errors.push(`MÃ¡ximo ${CONFIG.MAX_MULTIPLE_FILES} archivos permitidos. Tienes: ${this.files.length}`);
            console.error(`âŒ ERROR: LÃ­mite de archivos excedido: ${this.files.length} > ${CONFIG.MAX_MULTIPLE_FILES}`);
        }

        // 3. Verificar tamaÃ±o total
        if (this.totalSize > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
            errors.push(`TamaÃ±o total excedido (${formatFileSize(this.totalSize)} > ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)})`);
            console.error(`âŒ ERROR: TamaÃ±o total excedido: ${formatFileSize(this.totalSize)} > ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)}`);
        }

        // 4. VERIFICACIÃ“N DETALLADA DE CATEGORÃAS (CRÃTICO)
        console.log('ğŸ·ï¸ Verificando categorÃ­as...');
        const categoryCheck = this.checkCategories();
        console.log('ğŸ“Š Resultado verificaciÃ³n categorÃ­as:', {
            totalArchivos: categoryCheck.totalFiles,
            conCategorÃ­a: categoryCheck.filesWithCategory,
            sinCategorÃ­a: categoryCheck.missingCategories,
            todosTienenCategorÃ­a: categoryCheck.allHaveCategory
        });
        
        if (!categoryCheck.allHaveCategory) {
            const errorMsg = `${categoryCheck.missingCategories} archivo(s) no tienen categorÃ­a asignada`;
            errors.push(errorMsg);
            console.error(`âŒ ERROR: ${errorMsg}`);
            
            // Mostrar quÃ© archivos no tienen categorÃ­a
            const filesWithoutCategory = categoryCheck.details.filter(d => !d.hasCategory);
            console.error('âŒ Archivos SIN CATEGORÃA:', filesWithoutCategory.map(f => f.name));
            
            // Intentar asignar categorÃ­a comÃºn si existe
            if (this.commonCategory && this.commonCategory.trim() !== '') {
                console.log('ğŸ”„ Intentando asignar categorÃ­a comÃºn a archivos sin categorÃ­a...');
                let fixedCount = 0;
                this.files.forEach(file => {
                    const effectiveCategory = this.getEffectiveCategory(file);
                    if (!effectiveCategory || effectiveCategory.trim() === '') {
                        file.customCategory = this.commonCategory;
                        fixedCount++;
                        console.log(`âœ… Asignada categorÃ­a comÃºn a: ${file.file.name}`);
                    }
                });
                
                if (fixedCount > 0) {
                    console.log(`âœ… ${fixedCount} archivo(s) corregido(s) con categorÃ­a comÃºn`);
                    
                    // Re-verificar despuÃ©s de la correcciÃ³n
                    const newCheck = this.checkCategories();
                    if (newCheck.allHaveCategory) {
                        console.log('âœ… TODOS los archivos ahora tienen categorÃ­a');
                        // Remover el error si se corrigiÃ³
                        const errorIndex = errors.findIndex(e => e.includes('no tienen categorÃ­a'));
                        if (errorIndex !== -1) {
                            errors.splice(errorIndex, 1);
                            console.log('âœ… Error de categorÃ­as corregido automÃ¡ticamente');
                        }
                    } else {
                        console.error(`âŒ AÃºn hay ${newCheck.missingCategories} archivos sin categorÃ­a`);
                    }
                }
            } else {
                console.error('âŒ No hay categorÃ­a comÃºn para asignar');
            }
        }

        // 5. Verificar que todas las categorÃ­as sean vÃ¡lidas (no vacÃ­as)
        const invalidCategories = this.files.filter(f => {
            const cat = this.getEffectiveCategory(f);
            return !cat || cat.trim() === '';
        });
        
        if (invalidCategories.length > 0) {
            const errorMsg = `${invalidCategories.length} archivo(s) no tienen categorÃ­a vÃ¡lida`;
            errors.push(errorMsg);
            console.error(`âŒ ERROR: ${errorMsg}`);
            console.error('âŒ Archivos con categorÃ­a invÃ¡lida:', invalidCategories.map(f => f.file.name));
        }

        // 6. Verificar fechas de vencimiento (solo formato, no obligatorio)
        const invalidDates = [];
        this.files.forEach(file => {
            const date = this.getEffectiveExpirationDate(file);
            if (date && date.trim() !== '') {
                const dateObj = new Date(date);
                if (isNaN(dateObj.getTime())) {
                    invalidDates.push(file.file.name);
                }
            }
        });
        
        if (invalidDates.length > 0) {
            const errorMsg = `${invalidDates.length} archivo(s) tienen fecha de vencimiento invÃ¡lida`;
            errors.push(errorMsg);
            console.error(`âŒ ERROR: ${errorMsg}`);
            console.error('âŒ Archivos con fecha invÃ¡lida:', invalidDates);
        }

        // 7. Resultado final de la validaciÃ³n
        if (errors.length > 0) {
            console.error('âŒ ERRORES DE VALIDACIÃ“N ENCONTRADOS:', errors);
            console.log('ğŸ“Š Estado FINAL para debugging:');
            this.logState();
            
            // Mostrar alertas al usuario
            errors.forEach(error => showAlert(error, 'error'));
            
            console.groupEnd();
            return false;
        }

        console.log('âœ… VALIDACIÃ“N EXITOSA - Todos los archivos son vÃ¡lidos');
        console.log('ğŸ“Š Resumen FINAL:', {
            totalArchivos: this.files.length,
            archivosConCategoria: categoryCheck.filesWithCategory,
            categorÃ­aComÃºn: this.commonCategory || '(no establecida)',
            personaComÃºn: this.commonPersonId || '(no establecida)',
            dÃ­asExpiraciÃ³n: this.expirationDays !== null ? `${this.expirationDays} dÃ­as` : '(no establecido)',
            tamaÃ±oTotal: formatFileSize(this.totalSize),
            estado: 'LISTO PARA SUBIR'
        });
        
        console.groupEnd();
        return true;
    }

    /**
     * Obtiene la categorÃ­a efectiva para un archivo especÃ­fico.
     * Prioriza categorÃ­a personalizada sobre categorÃ­a comÃºn.
     * @param {object} fileObj - Objeto de archivo
     * @returns {string} - CategorÃ­a a usar
     */
    getEffectiveCategory(fileObj) {
        // Primero intenta usar la categorÃ­a personalizada
        if (fileObj.customCategory && fileObj.customCategory.trim() !== '') {
            return fileObj.customCategory.trim();
        }
        // Si no hay categorÃ­a personalizada, usa la comÃºn
        if (this.commonCategory && this.commonCategory.trim() !== '') {
            return this.commonCategory.trim();
        }
        // Si no hay ninguna, retorna vacÃ­o
        return '';
    }

    /**
     * Obtiene la persona efectiva para un archivo especÃ­fico.
     * Prioriza persona personalizada sobre persona comÃºn.
     * @param {object} fileObj - Objeto de archivo
     * @returns {string} - Persona a usar
     */
    getEffectivePersonId(fileObj) {
        // Primero intenta usar la persona personalizada
        if (fileObj.customPersonId && fileObj.customPersonId.trim() !== '') {
            return fileObj.customPersonId.trim();
        }
        // Si no hay persona personalizada, usa la comÃºn
        if (this.commonPersonId && this.commonPersonId.trim() !== '') {
            return this.commonPersonId.trim();
        }
        // Si no hay ninguna, retorna vacÃ­o
        return '';
    }

    /**
     * Obtiene la fecha de vencimiento efectiva para un archivo especÃ­fico.
     * @param {object} fileObj - Objeto de archivo
     * @returns {string|null} - Fecha de vencimiento o null
     */
    getEffectiveExpirationDate(fileObj) {
        // Primero intenta usar la fecha personalizada
        if (fileObj.customExpirationDate) {
            return fileObj.customExpirationDate;
        }
        // Si no hay fecha personalizada, calcula basada en dÃ­as comunes
        if (this.expirationDays !== null && this.expirationDays !== undefined && this.expirationDays > 0) {
            return this.calculateExpirationDate(this.expirationDays);
        }
        // Si no hay configuraciÃ³n, retorna null
        return null;
    }

    /**
     * Prepara los datos de todos los archivos para enviar al servidor.
     * @returns {Array} - Array de objetos preparados para subida
     */
    prepareFilesForUpload() {
        console.group('ğŸ“¤ [MultipleUploadState] PREPARANDO ARCHIVOS PARA SUBIDA');
        
        const preparedFiles = this.files.map((fileObj, index) => {
            const effectiveCategory = this.getEffectiveCategory(fileObj);
            const effectivePersonId = this.getEffectivePersonId(fileObj);
            const effectiveExpirationDate = this.getEffectiveExpirationDate(fileObj);
            
            // VALIDACIÃ“N CRÃTICA: Asegurar que tenemos categorÃ­a
            if (!effectiveCategory || effectiveCategory.trim() === '') {
                console.error(`âŒ ERROR CRÃTICO: ${fileObj.file.name} NO TIENE CATEGORÃA`);
                console.error(`   â€¢ customCategory: "${fileObj.customCategory}"`);
                console.error(`   â€¢ commonCategory: "${this.commonCategory}"`);
                console.error(`   â€¢ effectiveCategory: "${effectiveCategory}"`);
            }
            
            const preparedFile = {
                file: fileObj.file,
                fileName: fileObj.file.name,
                fileSize: fileObj.file.size,
                fileType: fileObj.file.type,
                description: fileObj.description || fileObj.file.name.replace(/\.[^/.]+$/, ""),
                category: effectiveCategory,
                personId: effectivePersonId,
                expirationDate: effectiveExpirationDate,
                notifyPerson: this.notifyPerson && effectivePersonId !== '',
                notifyExpiration: this.notifyExpiration && effectiveExpirationDate !== null,
                status: 'pending'
            };
            
            console.log(`${index + 1}. ${fileObj.file.name}`, {
                categorÃ­a: preparedFile.category || '(ERROR: vacÃ­a)',
                persona: preparedFile.personId || '(sin persona)',
                fechaVencimiento: preparedFile.expirationDate || '(sin fecha)',
                notificarPersona: preparedFile.notifyPerson,
                notificarVencimiento: preparedFile.notifyExpiration,
                tamaÃ±o: formatFileSize(preparedFile.fileSize)
            });
            
            return preparedFile;
        });
        
        console.log(`âœ… ${preparedFiles.length} archivo(s) preparado(s) para subida`);
        
        // VerificaciÃ³n CRÃTICA: Asegurar que todos tengan categorÃ­a
        const filesWithoutCategory = preparedFiles.filter(f => !f.category || f.category.trim() === '');
        if (filesWithoutCategory.length > 0) {
            console.error('âŒ ERROR CRÃTICO: Archivos sin categorÃ­a:', filesWithoutCategory.map(f => f.fileName));
            console.error('âŒ Esto causarÃ¡ que la subida falle en el servidor');
            
            // Intentar corregir asignando categorÃ­a comÃºn
            if (this.commonCategory && this.commonCategory.trim() !== '') {
                console.log('ğŸ”„ Intentando corregir asignando categorÃ­a comÃºn...');
                filesWithoutCategory.forEach(f => {
                    f.category = this.commonCategory;
                    console.log(`âœ… Corregido: ${f.fileName} â†’ categorÃ­a: "${this.commonCategory}"`);
                });
                
                // Re-verificar
                const remaining = preparedFiles.filter(f => !f.category || f.category.trim() === '');
                if (remaining.length === 0) {
                    console.log('âœ… Todos los archivos corregidos con categorÃ­a comÃºn');
                }
            }
            
            throw new Error(`${filesWithoutCategory.length} archivos no tienen categorÃ­a asignada`);
        }
        
        console.groupEnd();
        return preparedFiles;
    }

    /**
     * Genera un ID Ãºnico para un archivo basado en nombre, tamaÃ±o y timestamp.
     * @param {File} file - Archivo para generar ID
     * @returns {string} - ID Ãºnico del archivo
     */
    generateFileId(file) {
        const id = `file_${file.name}_${file.size}_${file.lastModified}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        return id;
    }

    /**
     * Actualiza el estado de un archivo especÃ­fico
     * @param {string} fileId - ID del archivo
     * @param {object} updates - Actualizaciones a aplicar
     */
    updateFile(fileId, updates) {
        console.log(`ğŸ“ [MultipleUploadState] updateFile: ${fileId}`);
        
        const fileIndex = this.files.findIndex(f => f.id === fileId);
        if (fileIndex !== -1) {
            const oldStatus = this.files[fileIndex].status;
            this.files[fileIndex] = { ...this.files[fileIndex], ...updates };
            
            if (updates.status === 'completed') {
                this.files[fileIndex].uploadedAt = new Date().toISOString();
            }
            
            console.log(`âœ… Archivo actualizado: ${this.files[fileIndex].file.name}`, {
                estadoAnterior: oldStatus,
                estadoNuevo: updates.status,
                cambios: Object.keys(updates)
            });
            
            return true;
        }
        
        console.log(`âŒ No se encontrÃ³ archivo con ID: ${fileId}`);
        return false;
    }

    /**
     * Limpia archivos segÃºn estado
     * @param {string} status - Estado de archivos a limpiar
     */
    cleanupFiles(status = null) {
        console.group(`ğŸ—‘ï¸ [MultipleUploadState] cleanupFiles`);
        console.log(`Estado a limpiar: ${status || 'todos'}`);
        console.log(`Archivos antes de limpiar: ${this.files.length}`);
        
        if (status) {
            const initialCount = this.files.length;
            this.files = this.files.filter(f => f.status !== status);
            const removedCount = initialCount - this.files.length;
            console.log(`âœ… ${removedCount} archivo(s) limpiado(s) con estado: ${status}`);
        } else {
            this.files = [];
            console.log('âœ… TODOS los archivos limpiados');
        }
        
        // Recalcular tamaÃ±o total
        this.totalSize = this.files.reduce((sum, f) => sum + f.file.size, 0);
        console.log(`ğŸ“Š Archivos despuÃ©s de limpiar: ${this.files.length}`);
        console.log(`ğŸ“Š TamaÃ±o total despuÃ©s de limpiar: ${formatFileSize(this.totalSize)}`);
        
        console.groupEnd();
    }

    /**
     * Obtiene estadÃ­sticas actuales del estado de subida.
     * @returns {object} - Objeto con conteos de archivos por estado y tamaÃ±os
     */
    getStats() {
        const stats = {
            total: this.files.length,
            pending: this.files.filter(f => f.status === 'pending').length,
            uploading: this.files.filter(f => f.status === 'uploading').length,
            completed: this.files.filter(f => f.status === 'completed').length,
            failed: this.files.filter(f => f.status === 'failed').length,
            totalSize: this.totalSize,
            uploadedSize: this.files
                .filter(f => f.status === 'completed')
                .reduce((sum, f) => sum + f.file.size, 0)
        };
        
        console.log(`ğŸ“ˆ [MultipleUploadState] getStats:`, stats);
        return stats;
    }

    /**
     * Verifica si todos los archivos tienen categorÃ­a
     * @returns {object} - Resultado de la verificaciÃ³n
     */
    checkCategories() {
        console.log(`ğŸ” [MultipleUploadState] checkCategories`);
        
        const details = this.files.map(f => {
            const effectiveCategory = this.getEffectiveCategory(f);
            const effectivePersonId = this.getEffectivePersonId(f);
            const effectiveExpirationDate = this.getEffectiveExpirationDate(f);
            
            return {
                name: f.file.name,
                hasCategory: !!(effectiveCategory && effectiveCategory.trim() !== ''),
                customCategory: f.customCategory || '(vacÃ­a)',
                effectiveCategory: effectiveCategory || '(sin categorÃ­a)',
                customPersonId: f.customPersonId || '(vacÃ­a)',
                effectivePersonId: effectivePersonId || '(sin persona)',
                customExpirationDate: f.customExpirationDate || '(sin fecha)',
                effectiveExpirationDate: effectiveExpirationDate || '(sin fecha)',
                status: f.status
            };
        });
        
        const filesWithCategory = details.filter(d => d.hasCategory).length;
        
        const result = {
            allHaveCategory: filesWithCategory === this.files.length,
            totalFiles: this.files.length,
            filesWithCategory: filesWithCategory,
            missingCategories: this.files.length - filesWithCategory,
            commonCategory: this.commonCategory,
            commonPersonId: this.commonPersonId,
            expirationDays: this.expirationDays,
            details: details
        };
        
        console.log(`ğŸ“Š Resultado checkCategories:`, {
            todosTienenCategorÃ­a: result.allHaveCategory,
            conCategorÃ­a: result.filesWithCategory,
            sinCategorÃ­a: result.missingCategories
        });
        
        return result;
    }

    /**
     * Verifica si todos los archivos tienen persona asignada
     * @returns {object} - Resultado de la verificaciÃ³n
     */
    checkPersons() {
        console.log(`ğŸ‘¤ [MultipleUploadState] checkPersons`);
        
        const details = this.files.map(f => {
            const effectivePersonId = this.getEffectivePersonId(f);
            
            return {
                name: f.file.name,
                hasPerson: !!(effectivePersonId && effectivePersonId.trim() !== ''),
                effectivePersonId: effectivePersonId || '(sin persona)',
                status: f.status
            };
        });
        
        const filesWithPerson = details.filter(d => d.hasPerson).length;
        
        const result = {
            allHavePerson: filesWithPerson === this.files.length,
            totalFiles: this.files.length,
            filesWithPerson: filesWithPerson,
            missingPersons: this.files.length - filesWithPerson,
            commonPersonId: this.commonPersonId
        };
        
        console.log(`ğŸ“Š Resultado checkPersons:`, {
            todosTienenPersona: result.allHavePerson,
            conPersona: result.filesWithPerson,
            sinPersona: result.missingPersons
        });
        
        return result;
    }

    /**
     * Verifica si todos los archivos tienen fecha de vencimiento
     * @returns {object} - Resultado de la verificaciÃ³n
     */
    checkExpirations() {
        console.log(`ğŸ“… [MultipleUploadState] checkExpirations`);
        
        const details = this.files.map(f => {
            const effectiveExpirationDate = this.getEffectiveExpirationDate(f);
            
            return {
                name: f.file.name,
                hasExpiration: !!(effectiveExpirationDate),
                effectiveExpirationDate: effectiveExpirationDate || '(sin fecha)',
                status: f.status
            };
        });
        
        const filesWithExpiration = details.filter(d => d.hasExpiration).length;
        
        const result = {
            allHaveExpiration: filesWithExpiration === this.files.length,
            totalFiles: this.files.length,
            filesWithExpiration: filesWithExpiration,
            missingExpirations: this.files.length - filesWithExpiration,
            expirationDays: this.expirationDays
        };
        
        console.log(`ğŸ“Š Resultado checkExpirations:`, {
            todosTienenVencimiento: result.allHaveExpiration,
            conVencimiento: result.filesWithExpiration,
            sinVencimiento: result.missingExpirations
        });
        
        return result;
    }

    /**
     * Muestra en consola el estado actual de la subida mÃºltiple.
     * Ãštil para debugging y seguimiento de progreso.
     */
    logState() {
        console.group('ğŸ“Š [MultipleUploadState] ESTADO COMPLETO');
        
        const stats = this.getStats();
        console.log('ğŸ“ˆ ESTADÃSTICAS:');
        console.table({
            'Total Archivos': stats.total,
            'Pendientes': stats.pending,
            'Subiendo': stats.uploading,
            'Completados': stats.completed,
            'Fallidos': stats.failed,
            'TamaÃ±o Total': formatFileSize(stats.totalSize),
            'Subido': formatFileSize(stats.uploadedSize)
        });
        
        console.log('ğŸ”§ CONFIGURACIÃ“N COMÃšN:');
        console.log(`  â€¢ CategorÃ­a: "${this.commonCategory || '(NO ESTABLECIDA)'}"`);
        console.log(`  â€¢ Persona ID: "${this.commonPersonId || '(NO ESTABLECIDA)'}"`);
        console.log(`  â€¢ DÃ­as expiraciÃ³n: ${this.expirationDays !== null ? this.expirationDays + ' dÃ­as' : '(NO ESTABLECIDO)'}`);
        console.log(`  â€¢ Estrategia: ${this.uploadStrategy}`);
        console.log(`  â€¢ Auto-descripciones: ${this.autoGenerateDescriptions ? 'SÃ­' : 'No'}`);
        console.log(`  â€¢ Notificar persona: ${this.notifyPerson ? 'SÃ­' : 'No'}`);
        
        if (this.files.length > 0) {
            console.log('ğŸ“‹ DETALLE POR ARCHIVO:');
            this.files.forEach((file, index) => {
                const effectiveCategory = this.getEffectiveCategory(file);
                const effectivePersonId = this.getEffectivePersonId(file);
                const effectiveExpirationDate = this.getEffectiveExpirationDate(file);
                
                console.log(`${index + 1}. ${file.file.name}`, {
                    status: file.status,
                    progress: file.status === 'uploading' ? `${file.progress}%` : 'N/A',
                    'categorÃ­a.personalizada': file.customCategory || '(vacÃ­a)',
                    'categorÃ­a.efectiva': effectiveCategory || '(ERROR: sin categorÃ­a)',
                    'persona.personalizada': file.customPersonId || '(vacÃ­a)',
                    'persona.efectiva': effectivePersonId || '(sin persona)',
                    'vencimiento.personalizado': file.customExpirationDate || '(sin fecha)',
                    'vencimiento.efectivo': effectiveExpirationDate || '(sin fecha)',
                    error: file.error || 'N/A',
                    tamaÃ±o: formatFileSize(file.file.size)
                });
            });
        } else {
            console.log('ğŸ“‹ DETALLE POR ARCHIVO: (No hay archivos)');
        }
        
        console.groupEnd();
    }

    /**
     * Obtiene archivos por estado
     * @param {string} status - Estado a filtrar
     * @returns {Array} - Archivos con ese estado
     */
    getFilesByStatus(status) {
        const files = this.files.filter(f => f.status === status);
        console.log(`ğŸ“‹ [MultipleUploadState] getFilesByStatus(${status}): ${files.length} archivo(s)`);
        return files;
    }

    /**
     * Obtiene el siguiente archivo pendiente para subir
     * @returns {object|null} - Siguiente archivo o null
     */
    getNextPendingFile() {
        const nextFile = this.files.find(f => f.status === 'pending') || null;
        console.log(`â¡ï¸ [MultipleUploadState] getNextPendingFile:`, nextFile ? nextFile.file.name : 'null');
        return nextFile;
    }

    /**
     * Verifica si hay archivos pendientes
     * @returns {boolean} - True si hay archivos pendientes
     */
    hasPendingFiles() {
        const hasPending = this.files.some(f => f.status === 'pending');
        console.log(`â“ [MultipleUploadState] hasPendingFiles: ${hasPending}`);
        return hasPending;
    }

    /**
     * Verifica si todos los archivos estÃ¡n completados
     * @returns {boolean} - True si todos estÃ¡n completados
     */
    allFilesCompleted() {
        const allCompleted = this.files.every(f => f.status === 'completed' || f.status === 'failed');
        console.log(`â“ [MultipleUploadState] allFilesCompleted: ${allCompleted}`);
        return allCompleted;
    }

    /**
     * DEPURACIÃ“N: Imprime informaciÃ³n detallada de un archivo especÃ­fico
     * @param {string} fileId - ID del archivo
     */
    debugFile(fileId) {
        console.group(`ğŸ› [MultipleUploadState] debugFile: ${fileId}`);
        
        const fileObj = this.files.find(f => f.id === fileId);
        if (fileObj) {
            console.log('ğŸ“‹ INFORMACIÃ“N DEL ARCHIVO:');
            console.log(`  â€¢ Nombre: ${fileObj.file.name}`);
            console.log(`  â€¢ TamaÃ±o: ${formatFileSize(fileObj.file.size)}`);
            console.log(`  â€¢ Tipo: ${fileObj.file.type}`);
            console.log(`  â€¢ Status: ${fileObj.status}`);
            console.log(`  â€¢ Progreso: ${fileObj.progress}%`);
            console.log(`  â€¢ Error: ${fileObj.error || 'Ninguno'}`);
            
            console.log('ğŸ·ï¸ CONFIGURACIÃ“N:');
            console.log(`  â€¢ CategorÃ­a personalizada: "${fileObj.customCategory || '(vacÃ­a)'}"`);
            console.log(`  â€¢ Persona personalizada: "${fileObj.customPersonId || '(vacÃ­a)'}"`);
            console.log(`  â€¢ Fecha vencimiento personalizada: "${fileObj.customExpirationDate || '(sin fecha)'}"`);
            
            console.log('ğŸ”§ VALORES EFECTIVOS:');
            console.log(`  â€¢ CategorÃ­a efectiva: "${this.getEffectiveCategory(fileObj) || '(ERROR: vacÃ­a)'}"`);
            console.log(`  â€¢ Persona efectiva: "${this.getEffectivePersonId(fileObj) || '(sin persona)'}"`);
            console.log(`  â€¢ Fecha vencimiento efectiva: "${this.getEffectiveExpirationDate(fileObj) || '(sin fecha)'}"`);
            
            console.log('ğŸŒ CONFIGURACIÃ“N COMÃšN:');
            console.log(`  â€¢ CategorÃ­a comÃºn: "${this.commonCategory || '(no establecida)'}"`);
            console.log(`  â€¢ Persona comÃºn: "${this.commonPersonId || '(no establecida)'}"`);
            console.log(`  â€¢ DÃ­as expiraciÃ³n: ${this.expirationDays !== null ? this.expirationDays + ' dÃ­as' : 'no establecido'}`);
        } else {
            console.log(`âŒ No se encontrÃ³ archivo con ID: ${fileId}`);
        }
        
        console.groupEnd();
    }
}