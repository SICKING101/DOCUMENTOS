// =============================================================================
// src/frontend/modules/documentos/core/MultipleUploadState.js
// =============================================================================

import { CONFIG } from '../../../config.js';
import { formatFileSize, showAlert } from '../../../utils.js';

/**
 * Clase que gestiona el estado completo de la subida m√∫ltiple de archivos.
 * Controla archivos pendientes, en progreso, completados y fallidos,
 * as√≠ como configuraciones comunes para todos los archivos.
 */
export class MultipleUploadState {
    constructor() {
        console.log('üÜï [MultipleUploadState] Constructor - Creando nueva instancia');
        this.reset();
    }

    /**
     * Reinicia completamente el estado de subida m√∫ltiple.
     * √ötil para comenzar una nueva sesi√≥n de subida.
     */
    reset() {
        console.log('üîÑ [MultipleUploadState] Reset - Reiniciando estado completo');
        this.files = [];
        this.currentUploads = [];
        this.completedUploads = [];
        this.failedUploads = [];
        this.isUploading = false;
        this.totalSize = 0;
        this.commonCategory = '';
        this.commonPersonId = '';
        this.expirationDays = null;
        this.uploadStrategy = 'sequential';
        this.autoGenerateDescriptions = true;
        this.notifyPerson = false;
        this.notifyExpiration = true;
        
        console.log('‚úÖ [MultipleUploadState] Reset completado:', {
            filesCount: 0,
            commonCategory: '(vac√≠o)',
            commonPersonId: '(vac√≠o)',
            expirationDays: null,
            totalSize: '0 bytes'
        });
    }

    /**
     * Agrega nuevos archivos al estado, validando cada uno individualmente.
     * Evita duplicados y aplica validaciones de tipo y tama√±o.
     * @param {File[]} newFiles - Array de archivos a agregar
     * @returns {number} - Cantidad de archivos agregados
     */
    addFiles(newFiles) {
        console.group('üì¶ [MultipleUploadState] addFiles');
        console.log('üìÅ Archivos recibidos para agregar:', newFiles.length);
        
        // Mostrar estado actual antes de agregar
        console.log('üìä Estado ACTUAL antes de agregar:', {
            totalArchivos: this.files.length,
            commonCategory: `"${this.commonCategory}"`,
            commonPersonId: `"${this.commonPersonId}"`,
            expirationDays: this.expirationDays,
            totalSize: formatFileSize(this.totalSize)
        });
        
        let addedCount = 0;
        
        for (const file of newFiles) {
            // Verificar si ya existe
            const existingFile = this.files.find(f => 
                f.file.name === file.name && 
                f.file.size === file.size &&
                f.file.lastModified === file.lastModified
            );
            
            if (!existingFile) {
                // Validar archivo individual
                if (this.validateSingleFile(file)) {
                    const fileObj = this.createFileObject(file);
                    this.files.push(fileObj);
                    this.totalSize += file.size;
                    addedCount++;
                    
                    console.log(`‚úÖ Archivo AGREGADO: ${file.name}`, {
                        size: formatFileSize(file.size),
                        id: fileObj.id,
                        customCategory: fileObj.customCategory || '(vac√≠a - usar√° com√∫n)',
                        customPersonId: fileObj.customPersonId || '(vac√≠a - usar√° com√∫n)',
                        customExpirationDate: fileObj.customExpirationDate || '(sin fecha - usar√° com√∫n)',
                        status: fileObj.status
                    });
                }
            } else {
                console.log(`‚ö†Ô∏è Archivo DUPLICADO ignorado: ${file.name}`);
            }
        }
        
        // Mostrar estado despu√©s de agregar
        console.log(`üìä Resumen de operaci√≥n addFiles:`);
        console.log(`   ‚Ä¢ Archivos recibidos: ${newFiles.length}`);
        console.log(`   ‚Ä¢ Archivos agregados: ${addedCount}`);
        console.log(`   ‚Ä¢ Duplicados ignorados: ${newFiles.length - addedCount}`);
        console.log(`   ‚Ä¢ Total archivos ahora: ${this.files.length}`);
        console.log(`   ‚Ä¢ Tama√±o total ahora: ${formatFileSize(this.totalSize)}`);
        
        // Mostrar detalles de configuraci√≥n actual
        console.log('üîß Configuraci√≥n actual aplicada:');
        console.log(`   ‚Ä¢ Categor√≠a com√∫n: "${this.commonCategory || '(no establecida)'}"`);
        console.log(`   ‚Ä¢ Persona com√∫n: "${this.commonPersonId || '(no establecida)'}"`);
        console.log(`   ‚Ä¢ D√≠as de expiraci√≥n: ${this.expirationDays !== null ? `${this.expirationDays} d√≠as` : 'no establecido'}`);
        
        // Si hay archivos, mostrar detalles de cada uno
        if (this.files.length > 0) {
            console.log('üìã Detalle de archivos en estado:');
            this.files.forEach((f, i) => {
                const effectiveCategory = this.getEffectiveCategory(f);
                const effectivePersonId = this.getEffectivePersonId(f);
                const effectiveExpirationDate = this.getEffectiveExpirationDate(f);
                
                console.log(`${i + 1}. ${f.file.name}`, {
                    status: f.status,
                    categor√≠a: effectiveCategory || '(ERROR: sin categor√≠a)',
                    persona: effectivePersonId || '(sin persona)',
                    vencimiento: effectiveExpirationDate || '(sin fecha)',
                    tama√±o: formatFileSize(f.file.size)
                });
            });
        }
        
        console.groupEnd();
        return addedCount;
    }

    /**
     * Crea un objeto de archivo con todas las propiedades necesarias
     * @param {File} file - Archivo a procesar
     * @returns {object} - Objeto de archivo completo
     */
    createFileObject(file) {
        console.log(`üìÑ [MultipleUploadState] createFileObject para: ${file.name}`);
        
        const fileObj = {
            file: file,
            id: this.generateFileId(file),
            status: 'pending',
            progress: 0,
            error: null,
            description: file.name.replace(/\.[^/.]+$/, ""), // Nombre sin extensi√≥n
            customCategory: '',
            customPersonId: '',
            customExpirationDate: null,
            addedAt: new Date().toISOString(),
            uploadedAt: null,
            retryCount: 0
        };
        
        console.log(`üìù Valores por defecto para ${file.name}:`, {
            customCategory: '(vac√≠o)',
            customPersonId: '(vac√≠o)',
            customExpirationDate: 'null'
        });
        
        // IMPORTANTE: Asignar valores comunes si existen
        // Esto asegura que los archivos tengan valores desde el principio
        
        // 1. Asignar categor√≠a com√∫n si existe
        if (this.commonCategory && this.commonCategory.trim() !== '') {
            fileObj.customCategory = this.commonCategory;
            console.log(`üè∑Ô∏è Asignando categor√≠a com√∫n "${this.commonCategory}" a: ${file.name}`);
        } else {
            console.log(`üè∑Ô∏è NO hay categor√≠a com√∫n para asignar a: ${file.name}`);
        }
        
        // 2. Asignar persona com√∫n si existe
        if (this.commonPersonId && this.commonPersonId.trim() !== '') {
            fileObj.customPersonId = this.commonPersonId;
            console.log(`üë§ Asignando persona com√∫n "${this.commonPersonId}" a: ${file.name}`);
        } else {
            console.log(`üë§ NO hay persona com√∫n para asignar a: ${file.name}`);
        }
        
        // 3. Calcular y asignar fecha de expiraci√≥n si hay d√≠as configurados
        if (this.expirationDays !== null && this.expirationDays > 0) {
            fileObj.customExpirationDate = this.calculateExpirationDate(this.expirationDays);
            console.log(`üìÖ Asignando fecha de vencimiento ${fileObj.customExpirationDate} a: ${file.name}`);
        } else {
            console.log(`üìÖ NO hay d√≠as de expiraci√≥n para calcular fecha para: ${file.name}`);
        }
        
        return fileObj;
    }

    /**
     * Calcula una fecha de vencimiento basada en d√≠as
     * @param {number} days - D√≠as a agregar
     * @returns {string} - Fecha en formato YYYY-MM-DD
     */
    calculateExpirationDate(days) {
        console.log(`üìÜ [MultipleUploadState] calculateExpirationDate: hoy + ${days} d√≠as`);
        
        const expirationDate = new Date();
        expirationDate.setDate(expirationDate.getDate() + days);
        const formattedDate = expirationDate.toISOString().split('T')[0];
        
        console.log(`üìÜ Fecha calculada: ${formattedDate}`);
        return formattedDate;
    }

    /**
     * Elimina un archivo del estado por su ID.
     * @param {string} fileId - ID √∫nico del archivo a eliminar
     * @returns {boolean} - True si se elimin√≥ correctamente
     */
    removeFile(fileId) {
        console.log(`üóëÔ∏è [MultipleUploadState] removeFile - ID: ${fileId}`);
        
        const index = this.files.findIndex(f => f.id === fileId);
        if (index !== -1) {
            const removedFile = this.files[index];
            this.totalSize -= removedFile.file.size;
            this.files.splice(index, 1);
            
            console.log(`‚úÖ Archivo REMOVIDO: ${removedFile.file.name}`, {
                tama√±oRestado: formatFileSize(removedFile.file.size),
                totalArchivosRestantes: this.files.length,
                tama√±oTotalAhora: formatFileSize(this.totalSize)
            });
            
            return true;
        }
        
        console.log(`‚ùå No se encontr√≥ archivo con ID: ${fileId}`);
        return false;
    }

    /**
     * Actualiza la categor√≠a com√∫n y la aplica a todos los archivos pendientes
     * @param {string} category - Nueva categor√≠a com√∫n
     */
    setCommonCategory(category) {
        console.group(`üè∑Ô∏è [MultipleUploadState] setCommonCategory`);
        console.log(`üìù Valor recibido: "${category}"`);
        console.log(`üìù Valor anterior: "${this.commonCategory}"`);
        
        // Guardar nueva categor√≠a
        const oldCategory = this.commonCategory;
        this.commonCategory = category ? category.trim() : '';
        
        console.log(`‚úÖ Categor√≠a com√∫n ACTUALIZADA: "${oldCategory}" ‚Üí "${this.commonCategory}"`);
        
        // Aplicar a todos los archivos pendientes sin categor√≠a personalizada
        let updatedCount = 0;
        this.files.forEach(file => {
            if (file.status === 'pending') {
                // Solo actualizar si no hay categor√≠a personalizada
                if (!file.customCategory || file.customCategory.trim() === '') {
                    file.customCategory = this.commonCategory;
                    updatedCount++;
                    console.log(`üîÑ Aplicada categor√≠a com√∫n a: ${file.file.name}`);
                } else {
                    console.log(`‚ö†Ô∏è ${file.file.name} ya tiene categor√≠a personalizada: "${file.customCategory}"`);
                }
            }
        });
        
        console.log(`üìä Resumen: ${updatedCount} archivo(s) actualizado(s) con categor√≠a com√∫n`);
        
        // Verificaci√≥n despu√©s de actualizar
        const categoryCheck = this.checkCategories();
        console.log(`üîç Verificaci√≥n POST-actualizaci√≥n:`, {
            totalArchivos: categoryCheck.totalFiles,
            conCategor√≠a: categoryCheck.filesWithCategory,
            sinCategor√≠a: categoryCheck.missingCategories
        });
        
        console.groupEnd();
    }

    /**
     * Actualiza la persona com√∫n y la aplica a todos los archivos pendientes
     * @param {string} personId - Nueva persona com√∫n
     */
    setCommonPersonId(personId) {
        console.group(`üë§ [MultipleUploadState] setCommonPersonId`);
        console.log(`üìù Valor recibido: "${personId}"`);
        console.log(`üìù Valor anterior: "${this.commonPersonId}"`);
        
        // FIX CR√çTICO #1: Manejar correctamente los valores "null" y "undefined"
        let processedPersonId = '';
        
        if (personId && personId.trim() !== '' && personId !== 'null' && personId !== 'undefined') {
            processedPersonId = personId.trim();
            console.log(`üë§ Persona ID procesada: "${processedPersonId}"`);
        } else {
            console.log(`üë§ Persona ID est√° vac√≠a/inv√°lida, se establecer√° como cadena vac√≠a`);
            processedPersonId = '';
        }
        
        // Guardar nueva persona
        const oldPersonId = this.commonPersonId;
        this.commonPersonId = processedPersonId;
        
        console.log(`‚úÖ Persona com√∫n ACTUALIZADA: "${oldPersonId}" ‚Üí "${this.commonPersonId}"`);
        
        // Aplicar a todos los archivos pendientes sin persona personalizada
        let updatedCount = 0;
        this.files.forEach(file => {
            if (file.status === 'pending') {
                // Solo actualizar si no hay persona personalizada
                if (!file.customPersonId || file.customPersonId.trim() === '') {
                    file.customPersonId = this.commonPersonId;
                    updatedCount++;
                    console.log(`üîÑ Aplicada persona com√∫n a: ${file.file.name}`);
                } else {
                    console.log(`‚ö†Ô∏è ${file.file.name} ya tiene persona personalizada: "${file.customPersonId}"`);
                }
            }
        });
        
        console.log(`üìä Resumen: ${updatedCount} archivo(s) actualizado(s) con persona com√∫n`);
        
        // Verificaci√≥n despu√©s de actualizar
        const filesWithPerson = this.files.filter(f => 
            this.getEffectivePersonId(f) && this.getEffectivePersonId(f).trim() !== ''
        ).length;
        console.log(`üîç Verificaci√≥n POST-actualizaci√≥n:`, {
            totalArchivos: this.files.length,
            conPersona: filesWithPerson,
            sinPersona: this.files.length - filesWithPerson
        });
        
        console.groupEnd();
    }

    /**
     * Actualiza los d√≠as de expiraci√≥n y calcula fechas para todos los archivos pendientes
     * @param {number|string} days - D√≠as hasta el vencimiento
     */
    setExpirationDays(days) {
        console.group(`üìÖ [MultipleUploadState] setExpirationDays`);
        console.log(`üìù Valor recibido: "${days}" (tipo: ${typeof days})`);
        console.log(`üìù Valor anterior: ${this.expirationDays}`);
        
        // Validar y convertir el valor
        const daysNumber = parseInt(days);
        
        if (isNaN(daysNumber) || daysNumber <= 0) {
            this.expirationDays = null;
            console.log('‚úÖ D√≠as de expiraci√≥n establecidos como: null (sin vencimiento)');
            
            // Eliminar fechas de vencimiento de todos los archivos pendientes sin fecha personalizada
            let clearedCount = 0;
            this.files.forEach(file => {
                if (file.status === 'pending') {
                    if (!file.customExpirationDate) {
                        file.customExpirationDate = null;
                        clearedCount++;
                    }
                }
            });
            console.log(`üóëÔ∏è ${clearedCount} archivo(s) con fecha de vencimiento limpiada`);
            
        } else {
            this.expirationDays = daysNumber;
            console.log(`‚úÖ D√≠as de expiraci√≥n establecidos: ${this.expirationDays} d√≠as`);
            
            // Calcular fecha de vencimiento
            const expirationDate = this.calculateExpirationDate(daysNumber);
            console.log(`üìÖ Fecha calculada para vencimiento: ${expirationDate}`);
            
            // Aplicar a todos los archivos pendientes sin fecha personalizada
            let updatedCount = 0;
            this.files.forEach(file => {
                if (file.status === 'pending') {
                    // Solo actualizar si no hay fecha personalizada
                    if (!file.customExpirationDate) {
                        file.customExpirationDate = expirationDate;
                        updatedCount++;
                        console.log(`üîÑ Aplicada fecha de vencimiento a: ${file.file.name}`);
                    } else {
                        console.log(`‚ö†Ô∏è ${file.file.name} ya tiene fecha personalizada: "${file.customExpirationDate}"`);
                    }
                }
            });
            
            console.log(`üìä Resumen: ${updatedCount} archivo(s) actualizado(s) con fecha de vencimiento`);
        }
        
        // Verificaci√≥n despu√©s de actualizar
        const filesWithDate = this.files.filter(f => 
            this.getEffectiveExpirationDate(f)
        ).length;
        console.log(`üîç Verificaci√≥n POST-actualizaci√≥n:`, {
            totalArchivos: this.files.length,
            conFechaVencimiento: filesWithDate,
            sinFechaVencimiento: this.files.length - filesWithDate
        });
        
        console.groupEnd();
    }

    /**
     * VALOR CR√çTICO: Aplica la configuraci√≥n com√∫n a TODOS los archivos pendientes
     * Esto asegura que todos los archivos tengan los valores correctos antes de subir
     * @returns {number} - N√∫mero de archivos actualizados
     */
    applyCommonSettingsToAllFiles() {
        console.group('üîÑ [MultipleUploadState] applyCommonSettingsToAllFiles');
        
        console.log('üîß Configuraci√≥n com√∫n actual:', {
            categor√≠a: `"${this.commonCategory || '(vac√≠a)'}"`,
            persona: `"${this.commonPersonId || '(vac√≠a)'}"`,
            d√≠asExpiraci√≥n: this.expirationDays !== null ? `${this.expirationDays} d√≠as` : 'null'
        });
        
        let updatedFiles = 0;
        let skippedFiles = 0;
        
        this.files.forEach((file, index) => {
            if (file.status === 'pending') {
                let fileUpdated = false;
                
                console.log(`${index + 1}. Procesando: ${file.file.name}`, {
                    categor√≠aActual: file.customCategory || '(vac√≠a)',
                    personaActual: file.customPersonId || '(vac√≠a)',
                    fechaActual: file.customExpirationDate || '(sin fecha)'
                });
                
                // 1. Aplicar categor√≠a com√∫n si no tiene personalizada
                if (this.commonCategory && this.commonCategory.trim() !== '') {
                    if (!file.customCategory || file.customCategory.trim() === '') {
                        file.customCategory = this.commonCategory;
                        fileUpdated = true;
                        console.log(`   üè∑Ô∏è Categor√≠a actualizada: "${this.commonCategory}"`);
                    } else {
                        console.log(`   ‚ö†Ô∏è Mantiene categor√≠a personalizada: "${file.customCategory}"`);
                    }
                } else {
                    console.log(`   ‚ùå No hay categor√≠a com√∫n para aplicar`);
                }
                
                // 2. Aplicar persona com√∫n si no tiene personalizada
                if (this.commonPersonId && this.commonPersonId.trim() !== '') {
                    if (!file.customPersonId || file.customPersonId.trim() === '') {
                        file.customPersonId = this.commonPersonId;
                        fileUpdated = true;
                        console.log(`   üë§ Persona actualizada: "${this.commonPersonId}"`);
                    } else {
                        console.log(`   ‚ö†Ô∏è Mantiene persona personalizada: "${file.customPersonId}"`);
                    }
                } else {
                    console.log(`   ‚ùå No hay persona com√∫n para aplicar`);
                }
                
                // 3. Aplicar fecha de vencimiento si no tiene personalizada y hay d√≠as configurados
                if (this.expirationDays !== null && this.expirationDays > 0) {
                    if (!file.customExpirationDate) {
                        const expirationDate = this.calculateExpirationDate(this.expirationDays);
                        file.customExpirationDate = expirationDate;
                        fileUpdated = true;
                        console.log(`   üìÖ Fecha actualizada: ${expirationDate} (+${this.expirationDays} d√≠as)`);
                    } else {
                        console.log(`   ‚ö†Ô∏è Mantiene fecha personalizada: "${file.customExpirationDate}"`);
                    }
                } else {
                    console.log(`   ‚ùå No hay d√≠as de expiraci√≥n para calcular fecha`);
                }
                
                if (fileUpdated) {
                    updatedFiles++;
                    console.log(`   ‚úÖ Archivo ACTUALIZADO con configuraci√≥n com√∫n`);
                } else {
                    skippedFiles++;
                    console.log(`   üîÑ Archivo MANTENIDO (ya tiene configuraci√≥n personalizada)`);
                }
                
                // Mostrar valores efectivos despu√©s de la aplicaci√≥n
                console.log(`   üìä Valores efectivos despu√©s:`, {
                    categor√≠a: this.getEffectiveCategory(file) || '(vac√≠a)',
                    persona: this.getEffectivePersonId(file) || '(vac√≠a)',
                    fecha: this.getEffectiveExpirationDate(file) || '(sin fecha)'
                });
            } else {
                console.log(`${index + 1}. ${file.file.name} - SKIP (estado: ${file.status})`);
            }
        });
        
        console.log('üìä RESUMEN:', {
            archivosTotales: this.files.length,
            archivosActualizados: updatedFiles,
            archivosMantenidos: skippedFiles,
            archivosConCategor√≠a: this.files.filter(f => this.getEffectiveCategory(f)).length,
            archivosConPersona: this.files.filter(f => this.getEffectivePersonId(f)).length,
            archivosConFecha: this.files.filter(f => this.getEffectiveExpirationDate(f)).length
        });
        
        console.groupEnd();
        return updatedFiles;
    }

    /**
     * Valida un archivo individual seg√∫n configuraciones del sistema.
     * Verifica tipo de archivo, tama√±o individual y tama√±o total acumulado.
     * @param {File} file - Archivo a validar
     * @returns {boolean} - True si el archivo es v√°lido
     */
    validateSingleFile(file) {
        console.log(`üîç [MultipleUploadState] validateSingleFile: ${file.name}`);
        
        try {
            // Validar tipo de archivo
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (!CONFIG.ALLOWED_FILE_TYPES.includes(fileExtension)) {
                console.error(`‚ùå Tipo NO PERMITIDO: ${fileExtension}`);
                console.error(`‚ùå Extensiones permitidas: ${CONFIG.ALLOWED_FILE_TYPES.join(', ')}`);
                showAlert(
                    `"${file.name}" - Tipo no permitido. Formatos aceptados: ${CONFIG.ALLOWED_FILE_TYPES.join(', ').toUpperCase()}`,
                    'error'
                );
                return false;
            }

            // Validar tama√±o individual
            if (file.size > CONFIG.MAX_FILE_SIZE) {
                console.error(`‚ùå Tama√±o EXCEDIDO: ${formatFileSize(file.size)} > ${formatFileSize(CONFIG.MAX_FILE_SIZE)}`);
                showAlert(
                    `"${file.name}" - Excede el tama√±o m√°ximo por archivo (${formatFileSize(CONFIG.MAX_FILE_SIZE)})`,
                    'error'
                );
                return false;
            }

            // Validar tama√±o total (si ya hay archivos)
            if (this.totalSize + file.size > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
                console.error(`‚ùå Tama√±o TOTAL excedido`);
                console.error(`‚ùå Actual: ${formatFileSize(this.totalSize)} + Nuevo: ${formatFileSize(file.size)} > L√≠mite: ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)}`);
                showAlert(
                    `"${file.name}" - Excede el tama√±o total permitido para m√∫ltiples archivos`,
                    'error'
                );
                return false;
            }

            console.log(`‚úÖ Archivo V√ÅLIDO: ${file.name}`);
            return true;

        } catch (error) {
            console.error(`‚ùå ERROR validando archivo ${file.name}:`, error);
            showAlert(`Error validando "${file.name}": ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Valida todos los archivos en el estado globalmente.
     * Verifica l√≠mites, categor√≠as y otros requisitos del sistema.
     * @returns {boolean} - True si todos los archivos son v√°lidos
     */
    validateAllFiles() {
        console.group('üîç [MultipleUploadState] VALIDACI√ìN COMPLETA');
        
        const errors = [];
        
        // Mostrar estado actual para debugging
        console.log('üìä Estado ACTUAL para validaci√≥n:', {
            totalArchivos: this.files.length,
            commonCategory: `"${this.commonCategory}"`,
            commonPersonId: `"${this.commonPersonId}"`,
            expirationDays: this.expirationDays,
            totalSize: formatFileSize(this.totalSize)
        });
        
        // 1. Verificar que haya archivos
        if (this.files.length === 0) {
            errors.push('No hay archivos seleccionados');
            console.error('‚ùå ERROR: No hay archivos para validar');
            console.groupEnd();
            return false;
        }

        // 2. Verificar l√≠mite de archivos
        if (this.files.length > CONFIG.MAX_MULTIPLE_FILES) {
            errors.push(`M√°ximo ${CONFIG.MAX_MULTIPLE_FILES} archivos permitidos. Tienes: ${this.files.length}`);
            console.error(`‚ùå ERROR: L√≠mite de archivos excedido: ${this.files.length} > ${CONFIG.MAX_MULTIPLE_FILES}`);
        }

        // 3. Verificar tama√±o total
        if (this.totalSize > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
            errors.push(`Tama√±o total excedido (${formatFileSize(this.totalSize)} > ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)})`);
            console.error(`‚ùå ERROR: Tama√±o total excedido: ${formatFileSize(this.totalSize)} > ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)}`);
        }

        // 4. VERIFICACI√ìN DETALLADA DE CATEGOR√çAS (CR√çTICO)
        console.log('üè∑Ô∏è Verificando categor√≠as...');
        const categoryCheck = this.checkCategories();
        console.log('üìä Resultado verificaci√≥n categor√≠as:', {
            totalArchivos: categoryCheck.totalFiles,
            conCategor√≠a: categoryCheck.filesWithCategory,
            sinCategor√≠a: categoryCheck.missingCategories,
            todosTienenCategor√≠a: categoryCheck.allHaveCategory
        });
        
        if (!categoryCheck.allHaveCategory) {
            const errorMsg = `${categoryCheck.missingCategories} archivo(s) no tienen categor√≠a asignada`;
            errors.push(errorMsg);
            console.error(`‚ùå ERROR: ${errorMsg}`);
            
            // Mostrar qu√© archivos no tienen categor√≠a
            const filesWithoutCategory = categoryCheck.details.filter(d => !d.hasCategory);
            console.error('‚ùå Archivos SIN CATEGOR√çA:', filesWithoutCategory.map(f => f.name));
            
            // Intentar asignar categor√≠a com√∫n si existe
            if (this.commonCategory && this.commonCategory.trim() !== '') {
                console.log('üîÑ Intentando asignar categor√≠a com√∫n a archivos sin categor√≠a...');
                let fixedCount = 0;
                this.files.forEach(file => {
                    const effectiveCategory = this.getEffectiveCategory(file);
                    if (!effectiveCategory || effectiveCategory.trim() === '') {
                        file.customCategory = this.commonCategory;
                        fixedCount++;
                        console.log(`‚úÖ Asignada categor√≠a com√∫n a: ${file.file.name}`);
                    }
                });
                
                if (fixedCount > 0) {
                    console.log(`‚úÖ ${fixedCount} archivo(s) corregido(s) con categor√≠a com√∫n`);
                    
                    // Re-verificar despu√©s de la correcci√≥n
                    const newCheck = this.checkCategories();
                    if (newCheck.allHaveCategory) {
                        console.log('‚úÖ TODOS los archivos ahora tienen categor√≠a');
                        // Remover el error si se corrigi√≥
                        const errorIndex = errors.findIndex(e => e.includes('no tienen categor√≠a'));
                        if (errorIndex !== -1) {
                            errors.splice(errorIndex, 1);
                            console.log('‚úÖ Error de categor√≠as corregido autom√°ticamente');
                        }
                    } else {
                        console.error(`‚ùå A√∫n hay ${newCheck.missingCategories} archivos sin categor√≠a`);
                    }
                }
            } else {
                console.error('‚ùå No hay categor√≠a com√∫n para asignar');
            }
        }

        // 5. Verificar que todas las categor√≠as sean v√°lidas (no vac√≠as)
        const invalidCategories = this.files.filter(f => {
            const cat = this.getEffectiveCategory(f);
            return !cat || cat.trim() === '';
        });
        
        if (invalidCategories.length > 0) {
            const errorMsg = `${invalidCategories.length} archivo(s) no tienen categor√≠a v√°lida`;
            errors.push(errorMsg);
            console.error(`‚ùå ERROR: ${errorMsg}`);
            console.error('‚ùå Archivos con categor√≠a inv√°lida:', invalidCategories.map(f => f.file.name));
        }

        // 6. Verificar fechas de vencimiento (solo formato, no obligatorio)
        const invalidDates = [];
        this.files.forEach(file => {
            const date = this.getEffectiveExpirationDate(file);
            if (date && date.trim() !== '') {
                const dateObj = new Date(date);
                if (isNaN(dateObj.getTime())) {
                    invalidDates.push(file.file.name);
                }
            }
        });
        
        if (invalidDates.length > 0) {
            const errorMsg = `${invalidDates.length} archivo(s) tienen fecha de vencimiento inv√°lida`;
            errors.push(errorMsg);
            console.error(`‚ùå ERROR: ${errorMsg}`);
            console.error('‚ùå Archivos con fecha inv√°lida:', invalidDates);
        }

        // 7. Resultado final de la validaci√≥n
        if (errors.length > 0) {
            console.error('‚ùå ERRORES DE VALIDACI√ìN ENCONTRADOS:', errors);
            console.log('üìä Estado FINAL para debugging:');
            this.logState();
            
            // Mostrar alertas al usuario
            errors.forEach(error => showAlert(error, 'error'));
            
            console.groupEnd();
            return false;
        }

        console.log('‚úÖ VALIDACI√ìN EXITOSA - Todos los archivos son v√°lidos');
        console.log('üìä Resumen FINAL:', {
            totalArchivos: this.files.length,
            archivosConCategoria: categoryCheck.filesWithCategory,
            categor√≠aCom√∫n: this.commonCategory || '(no establecida)',
            personaCom√∫n: this.commonPersonId || '(no establecida)',
            d√≠asExpiraci√≥n: this.expirationDays !== null ? `${this.expirationDays} d√≠as` : '(no establecido)',
            tama√±oTotal: formatFileSize(this.totalSize),
            estado: 'LISTO PARA SUBIR'
        });
        
        console.groupEnd();
        return true;
    }

    /**
     * Obtiene la categor√≠a efectiva para un archivo espec√≠fico.
     * Prioriza categor√≠a personalizada sobre categor√≠a com√∫n.
     * @param {object} fileObj - Objeto de archivo
     * @returns {string} - Categor√≠a a usar
     */
    getEffectiveCategory(fileObj) {
        // Primero intenta usar la categor√≠a personalizada
        if (fileObj.customCategory && fileObj.customCategory.trim() !== '') {
            return fileObj.customCategory.trim();
        }
        // Si no hay categor√≠a personalizada, usa la com√∫n
        if (this.commonCategory && this.commonCategory.trim() !== '') {
            return this.commonCategory.trim();
        }
        // Si no hay ninguna, retorna vac√≠o
        return '';
    }

    /**
     * Obtiene la persona efectiva para un archivo espec√≠fico.
     * Prioriza persona personalizada sobre persona com√∫n.
     * @param {object} fileObj - Objeto de archivo
     * @returns {string} - Persona a usar
     */
    getEffectivePersonId(fileObj) {
        // Primero intenta usar la persona personalizada
        if (fileObj.customPersonId && fileObj.customPersonId.trim() !== '') {
            return fileObj.customPersonId.trim();
        }
        // Si no hay persona personalizada, usa la com√∫n
        if (this.commonPersonId && this.commonPersonId.trim() !== '') {
            return this.commonPersonId.trim();
        }
        // Si no hay ninguna, retorna vac√≠o
        return '';
    }

    /**
     * Obtiene la fecha de vencimiento efectiva para un archivo espec√≠fico.
     * @param {object} fileObj - Objeto de archivo
     * @returns {string|null} - Fecha de vencimiento o null
     */
    getEffectiveExpirationDate(fileObj) {
        // Primero intenta usar la fecha personalizada
        if (fileObj.customExpirationDate) {
            return fileObj.customExpirationDate;
        }
        // Si no hay fecha personalizada, calcula basada en d√≠as comunes
        if (this.expirationDays !== null && this.expirationDays !== undefined && this.expirationDays > 0) {
            return this.calculateExpirationDate(this.expirationDays);
        }
        // Si no hay configuraci√≥n, retorna null
        return null;
    }

    /**
     * Prepara los datos de todos los archivos para enviar al servidor.
     * @returns {Array} - Array de objetos preparados para subida
     */
    prepareFilesForUpload() {
        console.group('üì§ [MultipleUploadState] PREPARANDO ARCHIVOS PARA SUBIDA');
        
        const preparedFiles = this.files.map((fileObj, index) => {
            const effectiveCategory = this.getEffectiveCategory(fileObj);
            const effectivePersonId = this.getEffectivePersonId(fileObj);
            const effectiveExpirationDate = this.getEffectiveExpirationDate(fileObj);
            
            // VALIDACI√ìN CR√çTICA: Asegurar que tenemos categor√≠a
            if (!effectiveCategory || effectiveCategory.trim() === '') {
                console.error(`‚ùå ERROR CR√çTICO: ${fileObj.file.name} NO TIENE CATEGOR√çA`);
                console.error(`   ‚Ä¢ customCategory: "${fileObj.customCategory}"`);
                console.error(`   ‚Ä¢ commonCategory: "${this.commonCategory}"`);
                console.error(`   ‚Ä¢ effectiveCategory: "${effectiveCategory}"`);
            }
            
            const preparedFile = {
                file: fileObj.file,
                fileName: fileObj.file.name,
                fileSize: fileObj.file.size,
                fileType: fileObj.file.type,
                description: fileObj.description || fileObj.file.name.replace(/\.[^/.]+$/, ""),
                category: effectiveCategory,
                personId: effectivePersonId,
                expirationDate: effectiveExpirationDate,
                notifyPerson: this.notifyPerson && effectivePersonId !== '',
                notifyExpiration: this.notifyExpiration && effectiveExpirationDate !== null,
                status: 'pending'
            };
            
            console.log(`${index + 1}. ${fileObj.file.name}`, {
                categor√≠a: preparedFile.category || '(ERROR: vac√≠a)',
                persona: preparedFile.personId || '(sin persona)',
                fechaVencimiento: preparedFile.expirationDate || '(sin fecha)',
                notificarPersona: preparedFile.notifyPerson,
                notificarVencimiento: preparedFile.notifyExpiration,
                tama√±o: formatFileSize(preparedFile.fileSize)
            });
            
            return preparedFile;
        });
        
        console.log(`‚úÖ ${preparedFiles.length} archivo(s) preparado(s) para subida`);
        
        // Verificaci√≥n CR√çTICA: Asegurar que todos tengan categor√≠a
        const filesWithoutCategory = preparedFiles.filter(f => !f.category || f.category.trim() === '');
        if (filesWithoutCategory.length > 0) {
            console.error('‚ùå ERROR CR√çTICO: Archivos sin categor√≠a:', filesWithoutCategory.map(f => f.fileName));
            console.error('‚ùå Esto causar√° que la subida falle en el servidor');
            
            // Intentar corregir asignando categor√≠a com√∫n
            if (this.commonCategory && this.commonCategory.trim() !== '') {
                console.log('üîÑ Intentando corregir asignando categor√≠a com√∫n...');
                filesWithoutCategory.forEach(f => {
                    f.category = this.commonCategory;
                    console.log(`‚úÖ Corregido: ${f.fileName} ‚Üí categor√≠a: "${this.commonCategory}"`);
                });
                
                // Re-verificar
                const remaining = preparedFiles.filter(f => !f.category || f.category.trim() === '');
                if (remaining.length === 0) {
                    console.log('‚úÖ Todos los archivos corregidos con categor√≠a com√∫n');
                }
            }
            
            throw new Error(`${filesWithoutCategory.length} archivos no tienen categor√≠a asignada`);
        }
        
        console.groupEnd();
        return preparedFiles;
    }

    /**
     * Genera un ID √∫nico para un archivo basado en nombre, tama√±o y timestamp.
     * @param {File} file - Archivo para generar ID
     * @returns {string} - ID √∫nico del archivo
     */
    generateFileId(file) {
        const id = `file_${file.name}_${file.size}_${file.lastModified}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        return id;
    }

    /**
     * Actualiza el estado de un archivo espec√≠fico
     * @param {string} fileId - ID del archivo
     * @param {object} updates - Actualizaciones a aplicar
     */
    updateFile(fileId, updates) {
        console.log(`üìù [MultipleUploadState] updateFile: ${fileId}`);
        
        const fileIndex = this.files.findIndex(f => f.id === fileId);
        if (fileIndex !== -1) {
            const oldStatus = this.files[fileIndex].status;
            this.files[fileIndex] = { ...this.files[fileIndex], ...updates };
            
            if (updates.status === 'completed') {
                this.files[fileIndex].uploadedAt = new Date().toISOString();
            }
            
            console.log(`‚úÖ Archivo actualizado: ${this.files[fileIndex].file.name}`, {
                estadoAnterior: oldStatus,
                estadoNuevo: updates.status,
                cambios: Object.keys(updates)
            });
            
            return true;
        }
        
        console.log(`‚ùå No se encontr√≥ archivo con ID: ${fileId}`);
        return false;
    }

    /**
     * Limpia archivos seg√∫n estado
     * @param {string} status - Estado de archivos a limpiar
     */
    cleanupFiles(status = null) {
        console.group(`üóëÔ∏è [MultipleUploadState] cleanupFiles`);
        console.log(`Estado a limpiar: ${status || 'todos'}`);
        console.log(`Archivos antes de limpiar: ${this.files.length}`);
        
        if (status) {
            const initialCount = this.files.length;
            this.files = this.files.filter(f => f.status !== status);
            const removedCount = initialCount - this.files.length;
            console.log(`‚úÖ ${removedCount} archivo(s) limpiado(s) con estado: ${status}`);
        } else {
            this.files = [];
            console.log('‚úÖ TODOS los archivos limpiados');
        }
        
        // Recalcular tama√±o total
        this.totalSize = this.files.reduce((sum, f) => sum + f.file.size, 0);
        console.log(`üìä Archivos despu√©s de limpiar: ${this.files.length}`);
        console.log(`üìä Tama√±o total despu√©s de limpiar: ${formatFileSize(this.totalSize)}`);
        
        console.groupEnd();
    }

    /**
     * Obtiene estad√≠sticas actuales del estado de subida.
     * @returns {object} - Objeto con conteos de archivos por estado y tama√±os
     */
    getStats() {
        const stats = {
            total: this.files.length,
            pending: this.files.filter(f => f.status === 'pending').length,
            uploading: this.files.filter(f => f.status === 'uploading').length,
            completed: this.files.filter(f => f.status === 'completed').length,
            failed: this.files.filter(f => f.status === 'failed').length,
            totalSize: this.totalSize,
            uploadedSize: this.files
                .filter(f => f.status === 'completed')
                .reduce((sum, f) => sum + f.file.size, 0)
        };
        
        console.log(`üìà [MultipleUploadState] getStats:`, stats);
        return stats;
    }

    /**
     * Verifica si todos los archivos tienen categor√≠a
     * @returns {object} - Resultado de la verificaci√≥n
     */
    checkCategories() {
        console.log(`üîç [MultipleUploadState] checkCategories`);
        
        const details = this.files.map(f => {
            const effectiveCategory = this.getEffectiveCategory(f);
            const effectivePersonId = this.getEffectivePersonId(f);
            const effectiveExpirationDate = this.getEffectiveExpirationDate(f);
            
            return {
                name: f.file.name,
                hasCategory: !!(effectiveCategory && effectiveCategory.trim() !== ''),
                customCategory: f.customCategory || '(vac√≠a)',
                effectiveCategory: effectiveCategory || '(sin categor√≠a)',
                customPersonId: f.customPersonId || '(vac√≠a)',
                effectivePersonId: effectivePersonId || '(sin persona)',
                customExpirationDate: f.customExpirationDate || '(sin fecha)',
                effectiveExpirationDate: effectiveExpirationDate || '(sin fecha)',
                status: f.status
            };
        });
        
        const filesWithCategory = details.filter(d => d.hasCategory).length;
        
        const result = {
            allHaveCategory: filesWithCategory === this.files.length,
            totalFiles: this.files.length,
            filesWithCategory: filesWithCategory,
            missingCategories: this.files.length - filesWithCategory,
            commonCategory: this.commonCategory,
            commonPersonId: this.commonPersonId,
            expirationDays: this.expirationDays,
            details: details
        };
        
        console.log(`üìä Resultado checkCategories:`, {
            todosTienenCategor√≠a: result.allHaveCategory,
            conCategor√≠a: result.filesWithCategory,
            sinCategor√≠a: result.missingCategories
        });
        
        return result;
    }

    /**
     * Verifica si todos los archivos tienen persona asignada
     * @returns {object} - Resultado de la verificaci√≥n
     */
    checkPersons() {
        console.log(`üë§ [MultipleUploadState] checkPersons`);
        
        const details = this.files.map(f => {
            const effectivePersonId = this.getEffectivePersonId(f);
            
            return {
                name: f.file.name,
                hasPerson: !!(effectivePersonId && effectivePersonId.trim() !== ''),
                effectivePersonId: effectivePersonId || '(sin persona)',
                status: f.status
            };
        });
        
        const filesWithPerson = details.filter(d => d.hasPerson).length;
        
        const result = {
            allHavePerson: filesWithPerson === this.files.length,
            totalFiles: this.files.length,
            filesWithPerson: filesWithPerson,
            missingPersons: this.files.length - filesWithPerson,
            commonPersonId: this.commonPersonId
        };
        
        console.log(`üìä Resultado checkPersons:`, {
            todosTienenPersona: result.allHavePerson,
            conPersona: result.filesWithPerson,
            sinPersona: result.missingPersons
        });
        
        return result;
    }

    /**
     * Verifica si todos los archivos tienen fecha de vencimiento
     * @returns {object} - Resultado de la verificaci√≥n
     */
    checkExpirations() {
        console.log(`üìÖ [MultipleUploadState] checkExpirations`);
        
        const details = this.files.map(f => {
            const effectiveExpirationDate = this.getEffectiveExpirationDate(f);
            
            return {
                name: f.file.name,
                hasExpiration: !!(effectiveExpirationDate),
                effectiveExpirationDate: effectiveExpirationDate || '(sin fecha)',
                status: f.status
            };
        });
        
        const filesWithExpiration = details.filter(d => d.hasExpiration).length;
        
        const result = {
            allHaveExpiration: filesWithExpiration === this.files.length,
            totalFiles: this.files.length,
            filesWithExpiration: filesWithExpiration,
            missingExpirations: this.files.length - filesWithExpiration,
            expirationDays: this.expirationDays
        };
        
        console.log(`üìä Resultado checkExpirations:`, {
            todosTienenVencimiento: result.allHaveExpiration,
            conVencimiento: result.filesWithExpiration,
            sinVencimiento: result.missingExpirations
        });
        
        return result;
    }

    /**
     * Muestra en consola el estado actual de la subida m√∫ltiple.
     * √ötil para debugging y seguimiento de progreso.
     */
    logState() {
        console.group('üìä [MultipleUploadState] ESTADO COMPLETO');
        
        const stats = this.getStats();
        console.log('üìà ESTAD√çSTICAS:');
        console.table({
            'Total Archivos': stats.total,
            'Pendientes': stats.pending,
            'Subiendo': stats.uploading,
            'Completados': stats.completed,
            'Fallidos': stats.failed,
            'Tama√±o Total': formatFileSize(stats.totalSize),
            'Subido': formatFileSize(stats.uploadedSize)
        });
        
        console.log('üîß CONFIGURACI√ìN COM√öN:');
        console.log(`  ‚Ä¢ Categor√≠a: "${this.commonCategory || '(NO ESTABLECIDA)'}"`);
        console.log(`  ‚Ä¢ Persona ID: "${this.commonPersonId || '(NO ESTABLECIDA)'}"`);
        console.log(`  ‚Ä¢ D√≠as expiraci√≥n: ${this.expirationDays !== null ? this.expirationDays + ' d√≠as' : '(NO ESTABLECIDO)'}`);
        console.log(`  ‚Ä¢ Estrategia: ${this.uploadStrategy}`);
        console.log(`  ‚Ä¢ Auto-descripciones: ${this.autoGenerateDescriptions ? 'S√≠' : 'No'}`);
        console.log(`  ‚Ä¢ Notificar persona: ${this.notifyPerson ? 'S√≠' : 'No'}`);
        
        if (this.files.length > 0) {
            console.log('üìã DETALLE POR ARCHIVO:');
            this.files.forEach((file, index) => {
                const effectiveCategory = this.getEffectiveCategory(file);
                const effectivePersonId = this.getEffectivePersonId(file);
                const effectiveExpirationDate = this.getEffectiveExpirationDate(file);
                
                console.log(`${index + 1}. ${file.file.name}`, {
                    status: file.status,
                    progress: file.status === 'uploading' ? `${file.progress}%` : 'N/A',
                    'categor√≠a.personalizada': file.customCategory || '(vac√≠a)',
                    'categor√≠a.efectiva': effectiveCategory || '(ERROR: sin categor√≠a)',
                    'persona.personalizada': file.customPersonId || '(vac√≠a)',
                    'persona.efectiva': effectivePersonId || '(sin persona)',
                    'vencimiento.personalizado': file.customExpirationDate || '(sin fecha)',
                    'vencimiento.efectivo': effectiveExpirationDate || '(sin fecha)',
                    error: file.error || 'N/A',
                    tama√±o: formatFileSize(file.file.size)
                });
            });
        } else {
            console.log('üìã DETALLE POR ARCHIVO: (No hay archivos)');
        }
        
        console.groupEnd();
    }

    /**
     * Obtiene archivos por estado
     * @param {string} status - Estado a filtrar
     * @returns {Array} - Archivos con ese estado
     */
    getFilesByStatus(status) {
        const files = this.files.filter(f => f.status === status);
        console.log(`üìã [MultipleUploadState] getFilesByStatus(${status}): ${files.length} archivo(s)`);
        return files;
    }

    /**
     * Obtiene el siguiente archivo pendiente para subir
     * @returns {object|null} - Siguiente archivo o null
     */
    getNextPendingFile() {
        const nextFile = this.files.find(f => f.status === 'pending') || null;
        console.log(`‚û°Ô∏è [MultipleUploadState] getNextPendingFile:`, nextFile ? nextFile.file.name : 'null');
        return nextFile;
    }

    /**
     * Verifica si hay archivos pendientes
     * @returns {boolean} - True si hay archivos pendientes
     */
    hasPendingFiles() {
        const hasPending = this.files.some(f => f.status === 'pending');
        console.log(`‚ùì [MultipleUploadState] hasPendingFiles: ${hasPending}`);
        return hasPending;
    }

    /**
     * Verifica si todos los archivos est√°n completados
     * @returns {boolean} - True si todos est√°n completados
     */
    allFilesCompleted() {
        const allCompleted = this.files.every(f => f.status === 'completed' || f.status === 'failed');
        console.log(`‚ùì [MultipleUploadState] allFilesCompleted: ${allCompleted}`);
        return allCompleted;
    }

    /**
     * DEPURACI√ìN: Imprime informaci√≥n detallada de un archivo espec√≠fico
     * @param {string} fileId - ID del archivo
     */
    debugFile(fileId) {
        console.group(`üêõ [MultipleUploadState] debugFile: ${fileId}`);
        
        const fileObj = this.files.find(f => f.id === fileId);
        if (fileObj) {
            console.log('üìã INFORMACI√ìN DEL ARCHIVO:');
            console.log(`  ‚Ä¢ Nombre: ${fileObj.file.name}`);
            console.log(`  ‚Ä¢ Tama√±o: ${formatFileSize(fileObj.file.size)}`);
            console.log(`  ‚Ä¢ Tipo: ${fileObj.file.type}`);
            console.log(`  ‚Ä¢ Status: ${fileObj.status}`);
            console.log(`  ‚Ä¢ Progreso: ${fileObj.progress}%`);
            console.log(`  ‚Ä¢ Error: ${fileObj.error || 'Ninguno'}`);
            
            console.log('üè∑Ô∏è CONFIGURACI√ìN:');
            console.log(`  ‚Ä¢ Categor√≠a personalizada: "${fileObj.customCategory || '(vac√≠a)'}"`);
            console.log(`  ‚Ä¢ Persona personalizada: "${fileObj.customPersonId || '(vac√≠a)'}"`);
            console.log(`  ‚Ä¢ Fecha vencimiento personalizada: "${fileObj.customExpirationDate || '(sin fecha)'}"`);
            
            console.log('üîß VALORES EFECTIVOS:');
            console.log(`  ‚Ä¢ Categor√≠a efectiva: "${this.getEffectiveCategory(fileObj) || '(ERROR: vac√≠a)'}"`);
            console.log(`  ‚Ä¢ Persona efectiva: "${this.getEffectivePersonId(fileObj) || '(sin persona)'}"`);
            console.log(`  ‚Ä¢ Fecha vencimiento efectiva: "${this.getEffectiveExpirationDate(fileObj) || '(sin fecha)'}"`);
            
            console.log('üåê CONFIGURACI√ìN COM√öN:');
            console.log(`  ‚Ä¢ Categor√≠a com√∫n: "${this.commonCategory || '(no establecida)'}"`);
            console.log(`  ‚Ä¢ Persona com√∫n: "${this.commonPersonId || '(no establecida)'}"`);
            console.log(`  ‚Ä¢ D√≠as expiraci√≥n: ${this.expirationDays !== null ? this.expirationDays + ' d√≠as' : 'no establecido'}`);
        } else {
            console.log(`‚ùå No se encontr√≥ archivo con ID: ${fileId}`);
        }
        
        console.groupEnd();
    }
}