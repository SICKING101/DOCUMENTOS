// =============================================================================
// src/frontend/modules/documentos/core/MultipleUploadState.js
// =============================================================================

import { CONFIG } from '../../../config.js';
import { formatFileSize, showAlert } from '../../../utils.js';

/**
 * Clase que gestiona el estado completo de la subida mÃºltiple de archivos.
 * Controla archivos pendientes, en progreso, completados y fallidos,
 * asÃ­ como configuraciones comunes para todos los archivos.
 */
export class MultipleUploadState {
    constructor() {
        console.log('ðŸ”„ Creando nueva instancia de MultipleUploadState');
        this.reset();
    }

    /**
     * Reinicia completamente el estado de subida mÃºltiple.
     * Ãštil para comenzar una nueva sesiÃ³n de subida.
     */
    reset() {
        console.log('ðŸ”„ Reseteando estado de subida mÃºltiple');
        this.files = [];
        this.currentUploads = [];
        this.completedUploads = [];
        this.failedUploads = [];
        this.isUploading = false;
        this.totalSize = 0;
        this.commonCategory = '';
        this.commonPersonId = '';
        this.expirationDays = null;
        this.uploadStrategy = 'sequential';
        this.autoGenerateDescriptions = true;
        this.notifyPerson = false;
        
        console.log('âœ… Estado reseteado:', {
            filesCount: this.files.length,
            commonCategory: this.commonCategory,
            totalSize: this.totalSize
        });
    }

    /**
     * Agrega nuevos archivos al estado, validando cada uno individualmente.
     * Evita duplicados y aplica validaciones de tipo y tamaÃ±o.
     * @param {File[]} newFiles - Array de archivos a agregar
     */
    addFiles(newFiles) {
        console.group('ðŸ“¦ Agregando archivos mÃºltiples');
        console.log('ðŸ“ Archivos recibidos:', newFiles.length);
        console.log('Estado actual de commonCategory:', this.commonCategory);
        
        for (const file of newFiles) {
            // Verificar si ya existe
            const existingFile = this.files.find(f => 
                f.file.name === file.name && 
                f.file.size === file.size &&
                f.file.lastModified === file.lastModified
            );
            
            if (!existingFile) {
                // Validar archivo individual
                if (this.validateSingleFile(file)) {
                    const fileObj = {
                        file: file,
                        id: this.generateFileId(file),
                        status: 'pending',
                        progress: 0,
                        error: null,
                        description: file.name.replace(/\.[^/.]+$/, ""), // Nombre sin extensiÃ³n
                        customCategory: '',
                        customPersonId: '',
                        customExpirationDate: null,
                        addedAt: new Date().toISOString()
                    };
                    
                    // Si hay categorÃ­a comÃºn, asignarla
                    if (this.commonCategory && this.commonCategory.trim() !== '') {
                        fileObj.customCategory = this.commonCategory;
                        console.log(`ðŸ·ï¸ Asignando categorÃ­a comÃºn "${this.commonCategory}" a: ${file.name}`);
                    }
                    
                    this.files.push(fileObj);
                    this.totalSize += file.size;
                    
                    console.log(`âœ… Archivo agregado: ${file.name} (${formatFileSize(file.size)})`, {
                        id: fileObj.id,
                        customCategory: fileObj.customCategory,
                        commonCategory: this.commonCategory
                    });
                }
            } else {
                console.log(`âš ï¸ Archivo duplicado ignorado: ${file.name}`);
            }
        }
        
        console.log(`ðŸ“Š Estado despuÃ©s de agregar:`, {
            totalArchivos: this.files.length,
            tamaÃ±oTotal: formatFileSize(this.totalSize),
            commonCategory: this.commonCategory,
            archivos: this.files.map(f => ({
                nombre: f.file.name,
                categoria: f.customCategory || '(vacÃ­a)',
                commonCategory: this.commonCategory
            }))
        });
        console.groupEnd();
        
        return this.files.length;
    }

    /**
     * Elimina un archivo del estado por su ID.
     * @param {string} fileId - ID Ãºnico del archivo a eliminar
     * @returns {boolean} - True si se eliminÃ³ correctamente
     */
    removeFile(fileId) {
        console.log(`ðŸ—‘ï¸ Intentando eliminar archivo con ID: ${fileId}`);
        const index = this.files.findIndex(f => f.id === fileId);
        if (index !== -1) {
            const removedFile = this.files[index];
            this.totalSize -= removedFile.file.size;
            this.files.splice(index, 1);
            console.log(`âœ… Archivo removido: ${removedFile.file.name}`);
            return true;
        }
        console.log(`âŒ No se encontrÃ³ archivo con ID: ${fileId}`);
        return false;
    }

    /**
     * Actualiza la categorÃ­a comÃºn y la aplica a todos los archivos pendientes
     * @param {string} category - Nueva categorÃ­a comÃºn
     */
    setCommonCategory(category) {
        console.log(`ðŸ·ï¸ setCommonCategory llamado con: "${category}"`);
        
        const oldCategory = this.commonCategory;
        this.commonCategory = category;
        
        console.log(`ðŸ“ CategorÃ­a comÃºn actualizada: "${oldCategory}" â†’ "${category}"`);
        
        // Aplicar a todos los archivos pendientes sin categorÃ­a personalizada
        let updatedCount = 0;
        this.files.forEach(file => {
            if (!file.customCategory && file.status === 'pending') {
                file.customCategory = category;
                updatedCount++;
            }
        });
        
        console.log(`ðŸ”„ ${updatedCount} archivos actualizados con categorÃ­a comÃºn`);
        console.log(`ðŸ“Š Estado despuÃ©s de setCommonCategory:`, {
            commonCategory: this.commonCategory,
            archivos: this.files.map(f => ({
                nombre: f.file.name,
                categoriaPersonalizada: f.customCategory || '(vacÃ­a)',
                status: f.status
            }))
        });
    }

    /**
     * Valida un archivo individual segÃºn configuraciones del sistema.
     * Verifica tipo de archivo, tamaÃ±o individual y tamaÃ±o total acumulado.
     * @param {File} file - Archivo a validar
     * @returns {boolean} - True si el archivo es vÃ¡lido
     */
    validateSingleFile(file) {
        try {
            console.log(`ðŸ” Validando archivo individual: ${file.name}`);
            
            // Validar tipo de archivo
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (!CONFIG.ALLOWED_FILE_TYPES.includes(fileExtension)) {
                console.error(`âŒ Tipo no permitido: ${fileExtension}`);
                showAlert(
                    `"${file.name}" - Tipo no permitido. Formatos aceptados: ${CONFIG.ALLOWED_FILE_TYPES.join(', ').toUpperCase()}`,
                    'error'
                );
                return false;
            }

            // Validar tamaÃ±o individual
            if (file.size > CONFIG.MAX_FILE_SIZE) {
                console.error(`âŒ TamaÃ±o excedido: ${formatFileSize(file.size)} > ${formatFileSize(CONFIG.MAX_FILE_SIZE)}`);
                showAlert(
                    `"${file.name}" - Excede el tamaÃ±o mÃ¡ximo por archivo (${formatFileSize(CONFIG.MAX_FILE_SIZE)})`,
                    'error'
                );
                return false;
            }

            // Validar tamaÃ±o total (si ya hay archivos)
            if (this.totalSize + file.size > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
                console.error(`âŒ TamaÃ±o total excedido`);
                showAlert(
                    `"${file.name}" - Excede el tamaÃ±o total permitido para mÃºltiples archivos`,
                    'error'
                );
                return false;
            }

            console.log(`âœ… Archivo vÃ¡lido: ${file.name}`);
            return true;

        } catch (error) {
            console.error(`âŒ Error validando archivo ${file.name}:`, error);
            showAlert(`Error validando "${file.name}": ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Valida todos los archivos en el estado globalmente.
     * Verifica lÃ­mites, categorÃ­as y otros requisitos del sistema.
     * @returns {boolean} - True si todos los archivos son vÃ¡lidos
     */
    validateAllFiles() {
        console.group('ðŸ” validateAllFiles - Validando todos los archivos');
        
        const errors = [];
        
        // Mostrar estado actual para debugging
        console.log('ðŸ“Š Estado actual para validaciÃ³n:', {
            totalArchivos: this.files.length,
            commonCategory: `"${this.commonCategory}"`,
            archivos: this.files.map((f, i) => ({
                index: i,
                nombre: f.file.name,
                customCategory: `"${f.customCategory}"`,
                status: f.status
            }))
        });
        
        // Verificar lÃ­mite de archivos
        if (this.files.length > CONFIG.MAX_MULTIPLE_FILES) {
            errors.push(`MÃ¡ximo ${CONFIG.MAX_MULTIPLE_FILES} archivos permitidos`);
        }

        // Verificar tamaÃ±o total
        if (this.totalSize > CONFIG.MAX_TOTAL_UPLOAD_SIZE) {
            errors.push(`TamaÃ±o total excedido (${formatFileSize(this.totalSize)} > ${formatFileSize(CONFIG.MAX_TOTAL_UPLOAD_SIZE)})`);
        }

        // Verificar que haya archivos
        if (this.files.length === 0) {
            errors.push('No hay archivos seleccionados');
            console.error('âŒ No hay archivos para validar');
            console.groupEnd();
            return false;
        }

        // VERIFICACIÃ“N DETALLADA DE CATEGORÃAS
        console.log('ðŸ” Verificando categorÃ­as...');
        
        const hasCommonCategory = this.commonCategory && this.commonCategory.trim() !== '';
        console.log(`ðŸ·ï¸ Tiene categorÃ­a comÃºn: ${hasCommonCategory} ("${this.commonCategory}")`);
        
        // Contar archivos con categorÃ­a personalizada
        const filesWithCustomCategory = this.files.filter(f => 
            f.customCategory && f.customCategory.trim() !== ''
        );
        console.log(`ðŸ“Š Archivos con categorÃ­a personalizada: ${filesWithCustomCategory.length}/${this.files.length}`);
        
        // Identificar archivos sin categorÃ­a
        const filesWithoutCategory = this.files.filter(f => 
            !f.customCategory || f.customCategory.trim() === ''
        );
        
        if (filesWithoutCategory.length > 0) {
            console.log('âŒ Archivos sin categorÃ­a:', filesWithoutCategory.map(f => f.file.name));
            
            if (!hasCommonCategory) {
                errors.push('Debe seleccionar una categorÃ­a comÃºn para todos los archivos o individualmente');
                console.log('âŒ FALLÃ“: No hay categorÃ­a comÃºn y algunos archivos no tienen categorÃ­a personalizada');
            } else {
                console.log('âœ… Hay categorÃ­a comÃºn, aplicÃ¡ndola a archivos sin categorÃ­a...');
                // Aplicar categorÃ­a comÃºn a archivos sin categorÃ­a
                filesWithoutCategory.forEach(file => {
                    file.customCategory = this.commonCategory;
                    console.log(`ðŸ·ï¸ Aplicando categorÃ­a comÃºn "${this.commonCategory}" a: ${file.file.name}`);
                });
                
                // Verificar nuevamente despuÃ©s de aplicar
                const stillWithoutCategory = this.files.filter(f => 
                    !f.customCategory || f.customCategory.trim() === ''
                );
                if (stillWithoutCategory.length === 0) {
                    console.log('âœ… Todos los archivos ahora tienen categorÃ­a');
                } else {
                    console.log('âŒ Algunos archivos siguen sin categorÃ­a:', stillWithoutCategory.map(f => f.file.name));
                    errors.push('Algunos archivos no tienen categorÃ­a asignada');
                }
            }
        } else {
            console.log('âœ… Todos los archivos tienen categorÃ­a personalizada');
        }

        // Verificar que todas las categorÃ­as sean vÃ¡lidas
        const invalidCategories = this.files.filter(f => {
            const cat = this.getEffectiveCategory(f);
            return !cat || cat.trim() === '';
        });
        
        if (invalidCategories.length > 0) {
            errors.push(`${invalidCategories.length} archivo(s) no tienen categorÃ­a vÃ¡lida`);
            console.log('âŒ Archivos sin categorÃ­a vÃ¡lida:', invalidCategories.map(f => f.file.name));
        }

        if (errors.length > 0) {
            console.error('âŒ Errores de validaciÃ³n:', errors);
            console.log('ðŸ“Š Estado final para debugging:', {
                commonCategory: this.commonCategory,
                files: this.files.map(f => ({
                    name: f.file.name,
                    customCategory: f.customCategory,
                    effectiveCategory: this.getEffectiveCategory(f)
                }))
            });
            errors.forEach(error => showAlert(error, 'error'));
            console.groupEnd();
            return false;
        }

        console.log('âœ… ValidaciÃ³n exitosa - Todos los archivos son vÃ¡lidos');
        console.log('ðŸ“Š Resumen final:', {
            totalArchivos: this.files.length,
            archivosConCategoria: this.files.filter(f => this.getEffectiveCategory(f)).length,
            categorÃ­aComÃºn: this.commonCategory
        });
        console.groupEnd();
        return true;
    }

    /**
     * Obtiene la categorÃ­a efectiva para un archivo especÃ­fico.
     * Prioriza categorÃ­a personalizada sobre categorÃ­a comÃºn.
     * @param {object} fileObj - Objeto de archivo
     * @returns {string} - CategorÃ­a a usar
     */
    getEffectiveCategory(fileObj) {
        // Primero intenta usar la categorÃ­a personalizada
        if (fileObj.customCategory && fileObj.customCategory.trim() !== '') {
            return fileObj.customCategory.trim();
        }
        // Si no hay categorÃ­a personalizada, usa la comÃºn
        if (this.commonCategory && this.commonCategory.trim() !== '') {
            return this.commonCategory.trim();
        }
        // Si no hay ninguna, retorna vacÃ­o
        return '';
    }

    /**
     * Prepara los datos de todos los archivos para enviar al servidor.
     * @returns {Array} - Array de objetos preparados para subida
     */
    prepareFilesForUpload() {
        console.group('ðŸ“¤ Preparando archivos para subida');
        
        const preparedFiles = this.files.map(fileObj => {
            const effectiveCategory = this.getEffectiveCategory(fileObj);
            
            console.log(`ðŸ“‹ Preparando: ${fileObj.file.name}`, {
                customCategory: fileObj.customCategory,
                commonCategory: this.commonCategory,
                effectiveCategory: effectiveCategory
            });
            
            return {
                file: fileObj.file,
                fileName: fileObj.file.name,
                fileSize: fileObj.file.size,
                fileType: fileObj.file.type,
                description: fileObj.description || fileObj.file.name.replace(/\.[^/.]+$/, ""),
                category: effectiveCategory,
                personId: fileObj.customPersonId || this.commonPersonId || '',
                expirationDate: fileObj.customExpirationDate || this.expirationDays,
                notifyPerson: this.notifyPerson
            };
        });
        
        console.log('âœ… Archivos preparados:', preparedFiles.length);
        console.groupEnd();
        
        return preparedFiles;
    }

    /**
     * Genera un ID Ãºnico para un archivo basado en nombre, tamaÃ±o y timestamp.
     * @param {File} file - Archivo para generar ID
     * @returns {string} - ID Ãºnico del archivo
     */
    generateFileId(file) {
        return `${file.name}_${file.size}_${file.lastModified}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Obtiene estadÃ­sticas actuales del estado de subida.
     * @returns {object} - Objeto con conteos de archivos por estado y tamaÃ±os
     */
    getStats() {
        return {
            total: this.files.length,
            pending: this.files.filter(f => f.status === 'pending').length,
            uploading: this.files.filter(f => f.status === 'uploading').length,
            completed: this.files.filter(f => f.status === 'completed').length,
            failed: this.files.filter(f => f.status === 'failed').length,
            totalSize: this.totalSize,
            uploadedSize: this.files
                .filter(f => f.status === 'completed')
                .reduce((sum, f) => sum + f.file.size, 0)
        };
    }

    /**
     * Muestra en consola el estado actual de la subida mÃºltiple.
     * Ãštil para debugging y seguimiento de progreso.
     */
    logState() {
        console.group('ðŸ“Š Estado de Subida MÃºltiple - LOG STATE');
        const stats = this.getStats();
        console.table({
            'Total Archivos': stats.total,
            'Pendientes': stats.pending,
            'Subiendo': stats.uploading,
            'Completados': stats.completed,
            'Fallidos': stats.failed,
            'TamaÃ±o Total': formatFileSize(stats.totalSize),
            'Subido': formatFileSize(stats.uploadedSize)
        });
        
        // Mostrar detalles de cada archivo
        this.files.forEach((file, index) => {
            console.log(`${index + 1}. ${file.file.name}`, {
                status: file.status,
                customCategory: file.customCategory || '(vacÃ­a)',
                commonCategory: this.commonCategory || '(vacÃ­a)',
                effectiveCategory: this.getEffectiveCategory(file) || '(sin categorÃ­a)'
            });
        });
        
        console.log('ðŸ·ï¸ CategorÃ­a comÃºn:', this.commonCategory || '(no establecida)');
        console.groupEnd();
    }

    /**
     * Verifica si todos los archivos tienen categorÃ­a
     * @returns {object} - Resultado de la verificaciÃ³n
     */
    checkCategories() {
        const filesWithCategory = this.files.filter(f => 
            this.getEffectiveCategory(f) && this.getEffectiveCategory(f).trim() !== ''
        );
        
        return {
            allHaveCategory: filesWithCategory.length === this.files.length,
            totalFiles: this.files.length,
            filesWithCategory: filesWithCategory.length,
            missingCategories: this.files.length - filesWithCategory.length,
            commonCategory: this.commonCategory,
            details: this.files.map(f => ({
                name: f.file.name,
                hasCategory: !!(this.getEffectiveCategory(f) && this.getEffectiveCategory(f).trim() !== ''),
                customCategory: f.customCategory,
                effectiveCategory: this.getEffectiveCategory(f)
            }))
        };
    }
}